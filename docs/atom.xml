<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向南</title>
  
  
  <link href="https://wangmingco.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangmingco.github.io/"/>
  <updated>2022-01-10T09:31:05.903Z</updated>
  <id>https://wangmingco.github.io/</id>
  
  <author>
    <name>向南</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Centos 编译 OpenJDK</title>
    <link href="https://wangmingco.github.io/2022/01/10/jvm/centos%E7%BC%96%E8%AF%91openjdk/"/>
    <id>https://wangmingco.github.io/2022/01/10/jvm/centos%E7%BC%96%E8%AF%91openjdk/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-01-10T09:31:05.903Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/asciinema-player.js"></script><link rel="stylesheet" type="text/css" href="/assets/asciinema-player.css" /><p>按照如下过程进行编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;进入 openjdk-jdk-11-28版本JDK，如果没有请下载:&quot;</span><br><span class="line"></span><br><span class="line">cd openjdk-jdk-11-28</span><br><span class="line"></span><br><span class="line">echo &quot;查看系统版本&quot;</span><br><span class="line">cat /proc/version</span><br><span class="line">rpm -q centos-release</span><br><span class="line"></span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;安装依赖环境&quot;</span><br><span class="line">yum install -y freetype-devel cups-devel libXtst-devel libXt-devel libXrender-devel libXi-devel alsa-lib-devel libffi-devel autoconf fontconfig-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;安装Boot-JDK, 编译openjdk-11，需要以jdk-11为bootjdk&quot;</span><br><span class="line">yum install -y java-11-openjdk-devel</span><br><span class="line"></span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;安装开发工具&quot;</span><br><span class="line">yum groupinstall -y &quot;Development Tools&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;开始编译&quot;</span><br><span class="line">sh ./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>整个安装编译环境以及编译过程如下:</p><div id="/videos/jdk.cast"></div><script>AsciinemaPlayer.create("/videos/jdk.cast",document.getElementById("/videos/jdk.cast"));</script>或者打开 <p><a href="/html/compile_jdk.html">Centos 编译 OpenJDK</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;script src=&quot;/assets/asciinema-player.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/assets/asciinema-player.css&quot; /&gt;
&lt;p&gt;按照如下过程进行</summary>
      
    
    
    
    <category term="JVM" scheme="https://wangmingco.github.io/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>北京景点</title>
    <link href="https://wangmingco.github.io/2021/12/09/html/bj_baidu/"/>
    <id>https://wangmingco.github.io/2021/12/09/html/bj_baidu/</id>
    <published>2021-12-09T07:40:00.000Z</published>
    <updated>2021-12-09T08:05:41.190Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/html/bj_baidu.html">北京景点地图</a></p><p>    <div style="width:820px; height:1000px;border:none;text-align:center">        <iframe         allowtransparency="yes"         frameborder="0"         width="820px"         height="1000px"         scrolling="auto"         style="box-shadow: 0px 0px 20px -10px #888;"         src="/html/bj_baidu.html"/>    </div></p>    <p></script></p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/html/bj_baidu.html&quot;&gt;北京景点地图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
    &lt;div style=&quot;width:820px; height:1000px;border:none;text-align:center&quot;&gt;
        &lt;ifra</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>开发环境视频</title>
    <link href="https://wangmingco.github.io/2021/06/09/html/videos/"/>
    <id>https://wangmingco.github.io/2021/06/09/html/videos/</id>
    <published>2021-06-09T07:40:00.000Z</published>
    <updated>2021-12-16T05:04:32.741Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/html/video.html">开发环境视频</a></p><p>    <div style="width:820px; height:1000px;border:none;text-align:center">        <iframe         allowtransparency="yes"         frameborder="0"         width="820px"         height="1000px"         scrolling="auto"         style="box-shadow: 0px 0px 20px -10px #888;"         src="/html/video.html"/>    </div></p>    <p></script></p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/html/video.html&quot;&gt;开发环境视频&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
    &lt;div style=&quot;width:820px; height:1000px;border:none;text-align:center&quot;&gt;
        &lt;iframe </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java 线程状态</title>
    <link href="https://wangmingco.github.io/2020/05/13/zhihu/java_thread_state/"/>
    <id>https://wangmingco.github.io/2020/05/13/zhihu/java_thread_state/</id>
    <published>2020-05-13T08:36:00.000Z</published>
    <updated>2021-11-24T03:00:30.174Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/140396504">Java 线程状态</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/140396504&quot;&gt;Java 线程状态&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>写一个在线Java脚本执行器</title>
    <link href="https://wangmingco.github.io/2020/04/14/zhihu/java_script_runner/"/>
    <id>https://wangmingco.github.io/2020/04/14/zhihu/java_script_runner/</id>
    <published>2020-04-14T11:14:00.000Z</published>
    <updated>2021-11-24T03:00:24.016Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/130425196">写一个在线Java脚本执行器</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/130425196&quot;&gt;写一个在线Java脚本执行器&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>基于SpringBoot/Vue/ElementUI 构建权限系统</title>
    <link href="https://wangmingco.github.io/2020/04/14/zhihu/springboot_vue_admin/"/>
    <id>https://wangmingco.github.io/2020/04/14/zhihu/springboot_vue_admin/</id>
    <published>2020-04-14T10:42:00.000Z</published>
    <updated>2021-11-24T03:09:30.404Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/130412007">基于SpringBoot/Vue/ElementUI 构建权限系统</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/130412007&quot;&gt;基于SpringBoot/Vue/ElementUI 构建权限系统&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot Loader 浅析</title>
    <link href="https://wangmingco.github.io/2020/04/13/zhihu/SpringBoot_Loader/"/>
    <id>https://wangmingco.github.io/2020/04/13/zhihu/SpringBoot_Loader/</id>
    <published>2020-04-13T10:22:00.000Z</published>
    <updated>2021-11-24T03:00:39.388Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/129746554">SpringBoot Loader 浅析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/129746554&quot;&gt;SpringBoot Loader 浅析&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>PEG.js 文档 [译]</title>
    <link href="https://wangmingco.github.io/2020/04/02/zhihu/PEG_js/"/>
    <id>https://wangmingco.github.io/2020/04/02/zhihu/PEG_js/</id>
    <published>2020-04-02T10:45:00.000Z</published>
    <updated>2021-11-24T03:00:36.425Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/123294460">PEG.js 文档 [译]</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/123294460&quot;&gt;PEG.js 文档 [译]&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>当Netty遇上Spring Boot</title>
    <link href="https://wangmingco.github.io/2019/12/09/zhihu/springboot_netty/"/>
    <id>https://wangmingco.github.io/2019/12/09/zhihu/springboot_netty/</id>
    <published>2019-12-09T12:12:00.000Z</published>
    <updated>2021-11-24T02:59:34.854Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/96378920">当Netty遇上Spring Boot</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/96378920&quot;&gt;当Netty遇上Spring Boot&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>Java String intern() 实现细节</title>
    <link href="https://wangmingco.github.io/2019/07/03/zhihu/java_string_intern/"/>
    <id>https://wangmingco.github.io/2019/07/03/zhihu/java_string_intern/</id>
    <published>2019-07-03T12:01:00.000Z</published>
    <updated>2021-11-24T03:00:27.238Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/72054668">Java String intern() 实现细节</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72054668&quot;&gt;Java String intern() 实现细节&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>Java NIO原理剖析之 DirectBuffer GC</title>
    <link href="https://wangmingco.github.io/2019/05/20/zhihu/Java_DirectBuffer_GC/"/>
    <id>https://wangmingco.github.io/2019/05/20/zhihu/Java_DirectBuffer_GC/</id>
    <published>2019-05-20T06:44:00.000Z</published>
    <updated>2021-11-24T03:00:11.865Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/66368628">Java NIO原理剖析之 DirectBuffer GC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66368628&quot;&gt;Java NIO原理剖析之 DirectBuffer GC&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>Java NIO原理剖析之 磁盘IO</title>
    <link href="https://wangmingco.github.io/2019/05/20/zhihu/java_disc_io/"/>
    <id>https://wangmingco.github.io/2019/05/20/zhihu/java_disc_io/</id>
    <published>2019-05-20T02:37:00.000Z</published>
    <updated>2021-11-24T03:00:14.865Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/62255648">Java NIO原理剖析之 磁盘IO</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/62255648&quot;&gt;Java NIO原理剖析之 磁盘IO&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>Javasist Introspection and customization</title>
    <link href="https://wangmingco.github.io/2019/05/04/JavaLibrary/Javasist%204%20Introspection%20and%20customization/"/>
    <id>https://wangmingco.github.io/2019/05/04/JavaLibrary/Javasist%204%20Introspection%20and%20customization/</id>
    <published>2019-05-04T12:15:00.000Z</published>
    <updated>2021-11-18T03:12:28.690Z</updated>
    
    <content type="html"><![CDATA[<p><code>CtClass</code>提供了方法以便于自省. Javassist 的自省能力和Java的反射API很像. CtClass 提供了getName(), getSuperclass(), getMethods()等方法. CtClass仍然提供了修改一个类定义的方法.它允许添加新的字段/构造器/方法. 修改(Instrumenting)方法体也是可以的.</p><p>CtClass provides methods for introspection. The introspective ability of Javassist is compatible with that of the Java reflection API. CtClass provides getName(), getSuperclass(), getMethods(), and so on. CtClass also provides methods for modifying a class definition. It allows to add a new field, constructor, and method. Instrumenting a method body is also possible.</p><p>CtMethod实例表示方法. CtMethod提供了一些方法用来修改方法的定义. 注意, 如果一个方法是继承而来的, 那么子类和基类的这个方法是由同一个CtMethod对象表示. 一个CtMethod对象对应一个方法的声明.</p><p>Methods are represented by CtMethod objects. CtMethod provides several methods for modifying the definition of the method. Note that if a method is inherited from a super class, then the same CtMethod object that represents the inherited method represents the method declared in that super class. A CtMethod object corresponds to every method declaration.</p><p>例如, 如果类Point声明了一个方法<code>move()</code>, 它的子类<code>ColorPoint</code>没有重载<code>move()</code>方法, 在Point中声明的move()方法和在子类<code>ColorPoint</code>中继承过来的move()方法是由同一个CtMethod对象表示的. 如果CtMethod对象所表示的方法被修改了, 那么父类和子类的方法都会被修改. 如果你只想修改ColorPoint的<code>move()</code>方法, 你首席必须得把Point里的move()方法制作一个副本, 然后将这个副本添加到ColorPoint里. 可以通过调用CtNewMethod.copy()得到一个CtMethod对象的副本.</p><p>For example, if class Point declares method move() and a subclass ColorPoint of Point does not override move(), the two move() methods declared in Point and inherited in ColorPoint are represented by the identical CtMethod object. If the method definition represented by this CtMethod object is modified, the modification is reflected on both the methods. If you want to modify only the move() method in ColorPoint, you first have to add to ColorPoint a copy of the CtMethod object representing move() in Point. A copy of the the CtMethod object can be obtained by CtNewMethod.copy().</p><p>Javassist不允许删除一个方法或者字段, 但是允许修改它的名字. 索引, 如果一个方法不再需要了, 应该调用CtMethod的setName()将其重命名以及setModifiers()修改它的访问级别到一个私有方法.</p><p>Javassist does not allow to remove a method or field, but it allows to change the name. So if a method is not necessary any more, it should be renamed and changed to be a private method by calling setName() and setModifiers() declared in CtMethod.</p><p>Javassist也不允许向一个已经存在的方法添加一个新的参数. 但是, 可以向相同的class里增加一个新的方法, 该方法在老的方法接口上增加新的参数. 例如, 如果你想要在一个方法上添加一个newZ参数:</p><p>Javassist does not allow to add an extra parameter to an existing method, either. Instead of doing that, a new method receiving the extra parameter as well as the other parameters should be added to the same class. For example, if you want to add an extra int parameter newZ to a method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY)</span> </span>&#123; x = newX; y = newY; &#125;</span><br></pre></td></tr></table></figure><p>in a Point class, then you should add the following method to the Point class:</p><p>在Point类中, 你应该添加一个新的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> newX, <span class="keyword">int</span> newY, <span class="keyword">int</span> newZ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do what you want with newZ.</span></span><br><span class="line">    move(newX, newY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Javassist也提供了一些底层API用于修改一个原始的类结构. 例如, CtClass中的getClassFile()返回了一个表示原始类结构的ClassFile对象.CtMethod 中的 getMethodInfo() 返回了一个MethodInfo对象, 该对象表示的类结构中的一个method_info结构. 底层API使用了Java Virtual Machine规范中的词汇. 使用者必须有class文件和字节码的知识. 更多的细节, 使用者应该参考<code>javassist.bytecode</code>包下的内容.</p><p>Javassist also provides low-level API for directly editing a raw class file. For example, getClassFile() in CtClass returns a ClassFile object representing a raw class file. getMethodInfo() in CtMethod returns a MethodInfo object representing a method_info structure included in a class file. The low-level API uses the vocabulary from the Java Virtual machine specification. The users must have the knowledge about class files and bytecode. For more details, the users should see the javassist.bytecode package.</p><p>The class files modified by Javassist requires the javassist.runtime package for runtime support only if some special identifiers starting with $ are used. Those special identifiers are described below. The class files modified without those special identifiers do not need the javassist.runtime package or any other Javassist packages at runtime. For more details, see the API documentation of the javassist.runtime package.</p><h2 id="4-1-Inserting-source-text-at-the-beginning-end-of-a-method-body"><a href="#4-1-Inserting-source-text-at-the-beginning-end-of-a-method-body" class="headerlink" title="4.1 Inserting source text at the beginning/end of a method body"></a>4.1 Inserting source text at the beginning/end of a method body</h2><p>CtMethod and CtConstructor 中提供了insertBefore(), insertAfter(), and addCatch() 这三个方法. 这些方法用于向一个已经存在的方法中添加代码片段. 这些代码片段可以试Java代码. Javassist包含了一个简单的Java编译器用来编译这些Java源码. 该编译器接受Java语言编写的源代码, 然后将其编译成Java字节码, 然后将其内联到一个方法体中. </p><p>CtMethod and CtConstructor provide methods insertBefore(), insertAfter(), and addCatch(). They are used for inserting a code fragment into the body of an existing method. The users can specify those code fragments with source text written in Java. Javassist includes a simple Java compiler for processing source text. It receives source text written in Java and compiles it into Java bytecode, which will be inlined into a method body.</p><p>如果class文件中包含了line number表的话, 可以在指定的line number中插入一个代码片段.</p><p>Inserting a code fragment at the position specified by a line number is also possible (if the line number table is contained in the class file). insertAt() in CtMethod and CtConstructor takes source text and a line number in the source file of the original class definition. It compiles the source text and inserts the compiled code at the line number.</p><p>The methods insertBefore(), insertAfter(), addCatch(), and insertAt() receive a String object representing a statement or a block. A statement is a single control structure like if and while or an expression ending with a semi colon (;). A block is a set of statements surrounded with braces {}. Hence each of the following lines is an example of valid statement or block:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#123; System.out.println(<span class="string">&quot;Hello&quot;</span>); &#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123; i = -i; &#125;</span><br></pre></td></tr></table></figure><p>The statement and the block can refer to fields and methods. They can also refer to the parameters to the method that they are inserted into if that method was compiled with the -g option (to include a local variable attribute in the class file). Otherwise, they must access the method parameters through the special variables $0, $1, $2, … described below. Accessing local variables declared in the method is not allowed although declaring a new local variable in the block is allowed. However, insertAt() allows the statement and the block to access local variables if these variables are available at the specified line number and the target method was compiled with the -g option.<br>The String object passed to the methods insertBefore(), insertAfter(), addCatch(), and insertAt() are compiled by the compiler included in Javassist. Since the compiler supports language extensions, several identifiers starting with $ have special meaning:</p><ul><li><code>$0, $1, $2, ...</code>        this and actual parameters</li><li><code>$args</code>    An array of parameters. The type of $args is Object[].</li><li><code>$$</code>    All actual parameters. For example, m($$) is equivalent to m($1,$2,…)</li><li><code>$cflow(...)</code>    cflow variable</li><li><code>$r</code>    The result type. It is used in a cast expression.</li><li><code>$w</code>    The wrapper type. It is used in a cast expression.</li><li><code>$_</code>    The resulting value</li><li><code>$sig</code>    An array of java.lang.Class objects representing the formal parameter types.</li><li><code>$type</code>    A java.lang.Class object representing the formal result type.</li><li><code>$class</code>    A java.lang.Class object representing the class currently edited.</li></ul><h4 id="0-1-2-…"><a href="#0-1-2-…" class="headerlink" title="$0, $1, $2, …"></a>$0, $1, $2, …</h4><p>The parameters passed to the target method are accessible with $1, $2, … instead of the original parameter names. $1 represents the first parameter, $2 represents the second parameter, and so on. The types of those variables are identical to the parameter types. $0 is equivalent to this. If the method is static, $0 is not available.</p><p>These variables are used as following. Suppose that a class Point:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123; x += dx; y += dy; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To print the values of dx and dy whenever the method move() is called, execute this program:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">CtMethod m = cc.getDeclaredMethod(<span class="string">&quot;move&quot;</span>);</span><br><span class="line">m.insertBefore(<span class="string">&quot;&#123; System.out.println($1); System.out.println($2); &#125;&quot;</span>);</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure><p>Note that the source text passed to insertBefore() is surrounded with braces {}. insertBefore() accepts only a single statement or a block surrounded with braces.</p><p>The definition of the class Point after the modification is like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        &#123; System.out.println(dx); System.out.println(dy); &#125;</span><br><span class="line">        x += dx; y += dy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$1 and $2 are replaced with dx and dy, respectively.</p><p>$1, $2, $3 … are updatable. If a new value is assigend to one of those variables, then the value of the parameter represented by that variable is also updated.</p><h4 id="args"><a href="#args" class="headerlink" title="$args"></a>$args</h4><p>The variable $args represents an array of all the parameters. The type of that variable is an array of class Object. If a parameter type is a primitive type such as int, then the parameter value is converted into a wrapper object such as java.lang.Integer to store in $args. Thus, $args[0] is equivalent to $1 unless the type of the first parameter is a primitive type. Note that $args[0] is not equivalent to $0; $0 represents this.</p><p>If an array of Object is assigned to $args, then each element of that array is assigned to each parameter. If a parameter type is a primitive type, the type of the corresponding element must be a wrapper type. The value is converted from the wrapper type to the primitive type before it is assigned to the parameter.</p><h4 id=""><a href="#" class="headerlink" title="$$"></a>$$</h4><p>The variable $$ is abbreviation of a list of all the parameters separated by commas. For example, if the number of the parameters to method move() is three, then</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move($$)</span><br></pre></td></tr></table></figure><p>is equivalent to this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>If move() does not take any parameters, then move($$) is equivalent to move().</p><p>$$ can be used with another method. If you write an expression:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exMove($$, context)</span><br></pre></td></tr></table></figure><p>then this expression is equivalent to:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exMove($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, context)</span><br></pre></td></tr></table></figure><p>Note that $$ enables generic notation of method call with respect to the number of parameters. It is typically used with $proceed shown later.</p><h4 id="cflow"><a href="#cflow" class="headerlink" title="$cflow"></a>$cflow</h4><p>$cflow means “control flow”. This read-only variable returns the depth of the recursive calls to a specific method.</p><p>Suppose that the method shown below is represented by a CtMethod object cm:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To use $cflow, first declare that $cflow is used for monitoring calls to the method fact():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtMethod cm = ...;</span><br><span class="line">cm.useCflow(<span class="string">&quot;fact&quot;</span>);</span><br></pre></td></tr></table></figure><p>The parameter to useCflow() is the identifier of the declared $cflow variable. Any valid Java name can be used as the identifier. Since the identifier can also include . (dot), for example, “my.Test.fact” is a valid identifier.</p><p>Then, $cflow(fact) represents the depth of the recursive calls to the method specified by cm. The value of $cflow(fact) is 0 (zero) when the method is first called whereas it is 1 when the method is recursively called within the method. For example,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cm.insertBefore(<span class="string">&quot;if ($cflow(fact) == 0)&quot;</span></span><br><span class="line">              + <span class="string">&quot;    System.out.println(\&quot;fact \&quot; + $1);&quot;</span>);</span><br></pre></td></tr></table></figure><p>translates the method fact() so that it shows the parameter. Since the value of $cflow(fact) is checked, the method fact() does not show the parameter if it is recursively called within fact().</p><p>The value of $cflow is the number of stack frames associated with the specified method cm under the current topmost stack frame for the current thread. $cflow is also accessible within a method different from the specified method cm.</p><h4 id="r"><a href="#r" class="headerlink" title="$r"></a>$r</h4><p>$r represents the result type (return type) of the method. It must be used as the cast type in a cast expression. For example, this is a typical use:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object result = ... ;</span><br><span class="line">$_ = ($r)result;</span><br></pre></td></tr></table></figure><p>If the result type is a primitive type, then ($r) follows special semantics. First, if the operand type of the cast expression is a primitive type, ($r) works as a normal cast operator to the result type. On the other hand, if the operand type is a wrapper type, ($r) converts from the wrapper type to the result type. For example, if the result type is int, then ($r) converts from java.lang.Integer to int.</p><p>If the result type is void, then ($r) does not convert a type; it does nothing. However, if the operand is a call to a void method, then ($r) results in null. For example, if the result type is void and foo() is a void method, then</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_ = ($r)foo();</span><br></pre></td></tr></table></figure><p>is a valid statement.</p><p>The cast operator ($r) is also useful in a return statement. Even if the result type is void, the following return statement is valid:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ($r)result;</span><br></pre></td></tr></table></figure><p>Here, result is some local variable. Since ($r) is specified, the resulting value is discarded. This return statement is regarded as the equivalent of the return statement without a resulting value:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h4 id="w"><a href="#w" class="headerlink" title="$w"></a>$w</h4><p>$w represents a wrapper type. It must be used as the cast type in a cast expression. ($w) converts from a primitive type to the corresponding wrapper type. The following code is an example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = ($w)<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>The selected wrapper type depends on the type of the expression following ($w). If the type of the expression is double, then the wrapper type is java.lang.Double.</p><p>If the type of the expression following ($w) is not a primitive type, then ($w) does nothing.</p><h4 id="-1"><a href="#-1" class="headerlink" title="$_"></a>$_</h4><p>insertAfter() in CtMethod and CtConstructor inserts the compiled code at the end of the method. In the statement given to insertAfter(), not only the variables shown above such as $0, $1, … but also $_ is available.</p><p>The variable $_ represents the resulting value of the method. The type of that variable is the type of the result type (the return type) of the method. If the result type is void, then the type of $_ is Object and the value of $_ is null.</p><p>Although the compiled code inserted by insertAfter() is executed just before the control normally returns from the method, it can be also executed when an exception is thrown from the method. To execute it when an exception is thrown, the second parameter asFinally to insertAfter() must be true.</p><p>If an exception is thrown, the compiled code inserted by insertAfter() is executed as a finally clause. The value of $_ is 0 or null in the compiled code. After the execution of the compiled code terminates, the exception originally thrown is re-thrown to the caller. Note that the value of $_ is never thrown to the caller; it is rather discarded.</p><h4 id="sig"><a href="#sig" class="headerlink" title="$sig"></a>$sig</h4><p>The value of $sig is an array of java.lang.Class objects that represent the formal parameter types in declaration order.</p><h4 id="type"><a href="#type" class="headerlink" title="$type"></a>$type</h4><p>The value of $type is an java.lang.Class object representing the formal type of the result value. This variable refers to Void.class if this is a constructor.</p><h4 id="class"><a href="#class" class="headerlink" title="$class"></a>$class</h4><p>The value of $class is an java.lang.Class object representing the class in which the edited method is declared. This represents the type of $0.</p><h4 id="addCatch"><a href="#addCatch" class="headerlink" title="addCatch()"></a>addCatch()</h4><p>addCatch() inserts a code fragment into a method body so that the code fragment is executed when the method body throws an exception and the control returns to the caller. In the source text representing the inserted code fragment, the exception value is referred to with the special variable $e.</p><p>For example, this program:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CtMethod m = ...;</span><br><span class="line">CtClass etype = ClassPool.getDefault().get(<span class="string">&quot;java.io.IOException&quot;</span>);</span><br><span class="line">m.addCatch(<span class="string">&quot;&#123; System.out.println($e); throw $e; &#125;&quot;</span>, etype);</span><br><span class="line">translates the method body represented by m into something like <span class="keyword">this</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    the original method body</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the inserted code fragment must end with a throw or return statement.</p><h2 id="4-2-Altering-a-method-body"><a href="#4-2-Altering-a-method-body" class="headerlink" title="4.2 Altering a method body"></a>4.2 Altering a method body</h2><p>CtMethod and CtConstructor provide setBody() for substituting a whole method body. They compile the given source text into Java bytecode and substitutes it for the original method body. If the given source text is null, the substituted body includes only a return statement, which returns zero or null unless the result type is void.</p><p>In the source text given to setBody(), the identifiers starting with $ have special meaning</p><ul><li><code>$0, $1, $2, ...</code>        this and actual parameters</li><li><code>$args</code>    An array of parameters. The type of $args is Object[].</li><li><code>$$</code>    All actual parameters.</li><li><code>$cflow(...)</code>    cflow variable</li><li><code>$r</code>    The result type. It is used in a cast expression.</li><li><code>$w</code>    The wrapper type. It is used in a cast expression.</li><li><code>$sig</code>    An array of java.lang.Class objects representing the formal parameter types.</li><li><code>$type</code>    A java.lang.Class object representing the formal result type.</li><li><code>$class</code>    A java.lang.Class object representing the class that declares the method<br>currently edited (the type of $0).</li></ul><p>Note that $_ is not available.</p><h3 id="Substituting-source-text-for-an-existing-expression"><a href="#Substituting-source-text-for-an-existing-expression" class="headerlink" title="Substituting source text for an existing expression"></a>Substituting source text for an existing expression</h3><p>Javassist allows modifying only an expression included in a method body. javassist.expr.ExprEditor is a class for replacing an expression in a method body. The users can define a subclass of ExprEditor to specify how an expression is modified.</p><p>To run an ExprEditor object, the users must call instrument() in CtMethod or CtClass. For example,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CtMethod cm = ... ;</span><br><span class="line">cm.instrument(</span><br><span class="line">    <span class="keyword">new</span> ExprEditor() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(MethodCall m)</span></span></span><br><span class="line"><span class="function">                      <span class="keyword">throws</span> CannotCompileException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.getClassName().equals(<span class="string">&quot;Point&quot;</span>)</span><br><span class="line">                          &amp;&amp; m.getMethodName().equals(<span class="string">&quot;move&quot;</span>))</span><br><span class="line">                m.replace(<span class="string">&quot;&#123; $1 = 0; $_ = $proceed($$); &#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>searches the method body represented by cm and replaces all calls to move() in class Point with a block:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $<span class="number">1</span> = <span class="number">0</span>; $_ = $proceed($$); &#125;</span><br></pre></td></tr></table></figure><p>so that the first parameter to move() is always 0. Note that the substituted code is not an expression but a statement or a block. It cannot be or contain a try-catch statement.</p><p>The method instrument() searches a method body. If it finds an expression such as a method call, field access, and object creation, then it calls edit() on the given ExprEditor object. The parameter to edit() is an object representing the found expression. The edit() method can inspect and replace the expression through that object.</p><p>Calling replace() on the parameter to edit() substitutes the given statement or block for the expression. If the given block is an empty block, that is, if replace(“{}”) is executed, then the expression is removed from the method body. If you want to insert a statement (or a block) before/after the expression, a block like the following should be passed to replace():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; before-statements;</span><br><span class="line">  $_ = $proceed($$);</span><br><span class="line">  after-statements; &#125;</span><br></pre></td></tr></table></figure><p>whichever the expression is either a method call, field access, object creation, or others. The second statement could be:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_ = $proceed();</span><br></pre></td></tr></table></figure><p>if the expression is read access, or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$proceed($$);</span><br></pre></td></tr></table></figure><p>if the expression is write access.</p><p>Local variables available in the target expression is also available in the source text passed to replace() if the method searched by instrument() was compiled with the -g option (the class file includes a local variable attribute).</p><h3 id="javassist-expr-MethodCall"><a href="#javassist-expr-MethodCall" class="headerlink" title="javassist.expr.MethodCall"></a>javassist.expr.MethodCall</h3><p>A MethodCall object represents a method call. The method replace() in MethodCall substitutes a statement or a block for the method call. It receives source text representing the substitued statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().</p><p>$0    The target object of the method call.<br>This is not equivalent to this, which represents the caller-side this object.<br>$0 is null if the method is static.</p><p>$1, $2, …        The parameters of the method call.<br>$_    The resulting value of the method call.<br>$r    The result type of the method call.<br>$class        A java.lang.Class object representing the class declaring the method.<br>$sig        An array of java.lang.Class objects representing the formal parameter types.<br>$type        A java.lang.Class object representing the formal result type.<br>$proceed        The name of the method originally called in the expression.<br>Here the method call means the one represented by the MethodCall object.</p><p>The other identifiers such as $w, $args and $$ are also available.</p><p>Unless the result type of the method call is void, a value must be assigned to $_ in the source text and the type of $_ is the result type. If the result type is void, the type of $_ is Object and the value assigned to $_ is ignored.</p><p>$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).</p><h3 id="javassist-expr-ConstructorCall"><a href="#javassist-expr-ConstructorCall" class="headerlink" title="javassist.expr.ConstructorCall"></a>javassist.expr.ConstructorCall</h3><p>A ConstructorCall object represents a constructor call such as this() and super included in a constructor body. The method replace() in ConstructorCall substitutes a statement or a block for the constructor call. It receives source text representing the substituted statement or block, in which the identifiers starting with $ have special meaning as in the source text passed to insertBefore().</p><p>$0    The target object of the constructor call. This is equivalent to this.<br>$1, $2, …        The parameters of the constructor call.<br>$class        A java.lang.Class object representing the class declaring the constructor.<br>$sig        An array of java.lang.Class objects representing the formal parameter types.<br>$proceed        The name of the constructor originally called in the expression.<br>Here the constructor call means the one represented by the ConstructorCall object.</p><p>The other identifiers such as $w, $args and $$ are also available.</p><p>Since any constructor must call either a constructor of the super class or another constructor of the same class, the substituted statement must include a constructor call, normally a call to $proceed().</p><p>$proceed is not a String value but special syntax. It must be followed by an argument list surrounded by parentheses ( ).</p><h3 id="javassist-expr-FieldAccess"><a href="#javassist-expr-FieldAccess" class="headerlink" title="javassist.expr.FieldAccess"></a>javassist.expr.FieldAccess</h3><p>A FieldAccess object represents field access. The method edit() in ExprEditor receives this object if field access is found. The method replace() in FieldAccess receives source text representing the substitued statement or block for the field access.</p><p>In the source text, the identifiers starting with $ have special meaning:</p><p>$0    The object containing the field accessed by the expression. This is not equivalent to this.<br>this represents the object that the method including the expression is invoked on.<br>$0 is null if the field is static.</p><p>$1    The value that would be stored in the field if the expression is write access.<br>Otherwise, $1 is not available.</p><p>$_    The resulting value of the field access if the expression is read access.<br>Otherwise, the value stored in $_ is discarded.</p><p>$r    The type of the field if the expression is read access.<br>Otherwise, $r is void.</p><p>$class        A java.lang.Class object representing the class declaring the field.<br>$type    A java.lang.Class object representing the field type.<br>$proceed        The name of a virtual method executing the original field access. .<br>The other identifiers such as $w, $args and $$ are also available.</p><p>If the expression is read access, a value must be assigned to $_ in the source text. The type of $_ is the type of the field.</p><h3 id="javassist-expr-NewExpr"><a href="#javassist-expr-NewExpr" class="headerlink" title="javassist.expr.NewExpr"></a>javassist.expr.NewExpr</h3><p>A NewExpr object represents object creation with the new operator (not including array creation). The method edit() in ExprEditor receives this object if object creation is found. The method replace() in NewExpr receives source text representing the substitued statement or block for the object creation.</p><p>In the source text, the identifiers starting with $ have special meaning:</p><p>$0    null.<br>$1, $2, …        The parameters to the constructor.<br>$_    The resulting value of the object creation.<br>A newly created object must be stored in this variable.</p><p>$r    The type of the created object.<br>$sig        An array of java.lang.Class objects representing the formal parameter types.<br>$type        A java.lang.Class object representing the class of the created object.<br>$proceed        The name of a virtual method executing the original object creation. .<br>The other identifiers such as $w, $args and $$ are also available.</p><h3 id="javassist-expr-NewArray"><a href="#javassist-expr-NewArray" class="headerlink" title="javassist.expr.NewArray"></a>javassist.expr.NewArray</h3><p>A NewArray object represents array creation with the new operator. The method edit() in ExprEditor receives this object if array creation is found. The method replace() in NewArray receives source text representing the substitued statement or block for the array creation.</p><p>In the source text, the identifiers starting with $ have special meaning:</p><p>$0    null.<br>$1, $2, …        The size of each dimension.<br>$_    The resulting value of the array creation.<br>A newly created array must be stored in this variable.</p><p>$r    The type of the created array.<br>$type        A java.lang.Class object representing the class of the created array.<br>$proceed        The name of a virtual method executing the original array creation. .<br>The other identifiers such as $w, $args and $$ are also available.</p><p>For example, if the array creation is the following expression,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[][] s = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>then the value of $1 and $2 are 3 and 4, respectively. $3 is not available.<br>If the array creation is the following expression,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[][] s = <span class="keyword">new</span> String[<span class="number">3</span>][];</span><br></pre></td></tr></table></figure><p>then the value of $1 is 3 but $2 is not available.</p><h3 id="javassist-expr-Instanceof"><a href="#javassist-expr-Instanceof" class="headerlink" title="javassist.expr.Instanceof"></a>javassist.expr.Instanceof</h3><p>A Instanceof object represents an instanceof expression. The method edit() in ExprEditor receives this object if an instanceof expression is found. The method replace() in Instanceof receives source text representing the substitued statement or block for the expression.</p><p>In the source text, the identifiers starting with $ have special meaning:</p><p>$0    null.<br>$1    The value on the left hand side of the original instanceof operator.<br>$_    The resulting value of the expression. The type of $_ is boolean.<br>$r    The type on the right hand side of the instanceof operator.<br>$type    A java.lang.Class object representing the type on the right hand side of the instanceof operator.<br>$proceed        The name of a virtual method executing the original instanceof expression.<br>It takes one parameter (the type is java.lang.Object) and returns true<br>if the parameter value is an instance of the type on the right hand side of<br>the original instanceof operator. Otherwise, it returns false.</p><p>The other identifiers such as $w, $args and $$ are also available.</p><h3 id="javassist-expr-Cast"><a href="#javassist-expr-Cast" class="headerlink" title="javassist.expr.Cast"></a>javassist.expr.Cast</h3><p>A Cast object represents an expression for explicit type casting. The method edit() in ExprEditor receives this object if explicit type casting is found. The method replace() in Cast receives source text representing the substitued statement or block for the expression.</p><p>In the source text, the identifiers starting with $ have special meaning:</p><p>$0    null.<br>$1    The value the type of which is explicitly cast.<br>$_    The resulting value of the expression. The type of $_ is the same as the type<br>after the explicit casting, that is, the type surrounded by ( ).</p><p>$r    the type after the explicit casting, or the type surrounded by ( ).<br>$type    A java.lang.Class object representing the same type as $r.<br>$proceed        The name of a virtual method executing the original type casting.<br>It takes one parameter of the type java.lang.Object and returns it after<br>the explicit type casting specified by the original expression.</p><p>The other identifiers such as $w, $args and $$ are also available.</p><h3 id="javassist-expr-Handler"><a href="#javassist-expr-Handler" class="headerlink" title="javassist.expr.Handler"></a>javassist.expr.Handler</h3><p>A Handler object represents a catch clause of try-catch statement. The method edit() in ExprEditor receives this object if a catch is found. The method insertBefore() in Handler compiles the received source text and inserts it at the beginning of the catch clause.</p><p>In the source text, the identifiers starting with $ have meaning:</p><p>$1    The exception object caught by the catch clause.<br>$r    the type of the exception caught by the catch clause. It is used in a cast expression.<br>$w    The wrapper type. It is used in a cast expression.<br>$type        A java.lang.Class object representing<br>the type of the exception caught by the catch clause.</p><p>If a new exception object is assigned to $1, it is passed to the original catch clause as the caught exception.</p><h2 id="4-3-Adding-a-new-method-or-field"><a href="#4-3-Adding-a-new-method-or-field" class="headerlink" title="4.3 Adding a new method or field"></a>4.3 Adding a new method or field</h2><h3 id="Adding-a-method"><a href="#Adding-a-method" class="headerlink" title="Adding a method"></a>Adding a method</h3><p>Javassist allows the users to create a new method and constructor from scratch. CtNewMethod and CtNewConstructor provide several factory methods, which are static methods for creating CtMethod or CtConstructor objects. Especially, make() creates a CtMethod or CtConstructor object from the given source text.</p><p>For example, this program:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(</span><br><span class="line">                 <span class="string">&quot;public int xmove(int dx) &#123; x += dx; &#125;&quot;</span>,</span><br><span class="line">                 point);</span><br><span class="line">point.addMethod(m);</span><br></pre></td></tr></table></figure><p>adds a public method xmove() to class Point. In this example, x is a int field in the class Point.</p><p>The source text passed to make() can include the identifiers starting with $ except $_ as in setBody(). It can also include $proceed if the target object and the target method name are also given to make(). For example,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">CtMethod m = CtNewMethod.make(</span><br><span class="line">                 <span class="string">&quot;public int ymove(int dy) &#123; $proceed(0, dy); &#125;&quot;</span>,</span><br><span class="line">                 point, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;move&quot;</span>);</span><br></pre></td></tr></table></figure><p>this program creates a method ymove() defined below:</p><p>public int ymove(int dy) { this.move(0, dy); }<br>Note that $proceed has been replaced with this.move.</p><p>Javassist provides another way to add a new method. You can first create an abstract method and later give it a method body:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = <span class="keyword">new</span> CtMethod(CtClass.intType, <span class="string">&quot;move&quot;</span>,</span><br><span class="line">                          <span class="keyword">new</span> CtClass[] &#123; CtClass.intType &#125;, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">m.setBody(<span class="string">&quot;&#123; x += $1; &#125;&quot;</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure><p>Since Javassist makes a class abstract if an abstract method is added to the class, you have to explicitly change the class back to a non-abstract one after calling setBody().</p><h3 id="Mutual-recursive-methods"><a href="#Mutual-recursive-methods" class="headerlink" title="Mutual recursive methods"></a>Mutual recursive methods</h3><p>Javassist cannot compile a method if it calls another method that has not been added to a class. (Javassist can compile a method that calls itself recursively.) To add mutual recursive methods to a class, you need a trick shown below. Suppose that you want to add methods m() and n() to a class represented by cc:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">CtMethod m = CtNewMethod.make(<span class="string">&quot;public abstract int m(int i);&quot;</span>, cc);</span><br><span class="line">CtMethod n = CtNewMethod.make(<span class="string">&quot;public abstract int n(int i);&quot;</span>, cc);</span><br><span class="line">cc.addMethod(m);</span><br><span class="line">cc.addMethod(n);</span><br><span class="line">m.setBody(<span class="string">&quot;&#123; return ($1 &lt;= 0) ? 1 : (n($1 - 1) * $1); &#125;&quot;</span>);</span><br><span class="line">n.setBody(<span class="string">&quot;&#123; return m($1); &#125;&quot;</span>);</span><br><span class="line">cc.setModifiers(cc.getModifiers() &amp; ~Modifier.ABSTRACT);</span><br></pre></td></tr></table></figure><p>You must first make two abstract methods and add them to the class. Then you can give the method bodies to these methods even if the method bodies include method calls to each other. Finally you must change the class to a not-abstract class since addMethod() automatically changes a class into an abstract one if an abstract method is added.</p><h3 id="Adding-a-field"><a href="#Adding-a-field" class="headerlink" title="Adding a field"></a>Adding a field</h3><p>Javassist also allows the users to create a new field.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">&quot;z&quot;</span>, point);</span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure><p>This program adds a field named z to class Point.</p><p>If the initial value of the added field must be specified, the program shown above must be modified into:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">&quot;z&quot;</span>, point);</span><br><span class="line">point.addField(f, <span class="string">&quot;0&quot;</span>);    <span class="comment">// initial value is 0.</span></span><br></pre></td></tr></table></figure><p>Now, the method addField() receives the second parameter, which is the source text representing an expression computing the initial value. This source text can be any Java expression if the result type of the expression matches the type of the field. Note that an expression does not end with a semi colon (;).</p><p>Furthermore, the above code can be rewritten into the following simple code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass point = ClassPool.getDefault().get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">&quot;public int z = 0;&quot;</span>, point);</span><br><span class="line">point.addField(f);</span><br></pre></td></tr></table></figure><h3 id="Removing-a-member"><a href="#Removing-a-member" class="headerlink" title="Removing a member"></a>Removing a member</h3><p>To remove a field or a method, call removeField() or removeMethod() in CtClass. A CtConstructor can be removed by removeConstructor() in CtClass.</p><h2 id="4-4-Annotations"><a href="#4-4-Annotations" class="headerlink" title="4.4 Annotations"></a>4.4 Annotations</h2><p>CtClass, CtMethod, CtField and CtConstructor provides a convenient method getAnnotations() for reading annotations. It returns an annotation-type object.</p><p>For example, suppose the following annotation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">year</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This annotation is used as the following:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Author(name=&quot;Chiba&quot;, year=2005)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then, the value of the annotation can be obtained by getAnnotations(). It returns an array containing annotation-type objects.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ClassPool.getDefault().get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">Object[] all = cc.getAnnotations();</span><br><span class="line">Author a = (Author)all[<span class="number">0</span>];</span><br><span class="line">String name = a.name();</span><br><span class="line"><span class="keyword">int</span> year = a.year();</span><br><span class="line">System.out.println(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot;, year: &quot;</span> + year);</span><br></pre></td></tr></table></figure><p>This code snippet should print:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: Chiba, year: 2005</span><br></pre></td></tr></table></figure><p>Since the annoation of Point is only @Author, the length of the array all is one and all[0] is an Author object. The member values of the annotation can be obtained by calling name() and year() on the Author object.</p><p>To use getAnnotations(), annotation types such as Author must be included in the current class path. They must be also accessible from a ClassPool object. If the class file of an annotation type is not found, Javassist cannot obtain the default values of the members of that annotation type.</p><h2 id="4-5-Runtime-support-classes"><a href="#4-5-Runtime-support-classes" class="headerlink" title="4.5 Runtime support classes"></a>4.5 Runtime support classes</h2><p>In most cases, a class modified by Javassist does not require Javassist to run. However, some kinds of bytecode generated by the Javassist compiler need runtime support classes, which are in the javassist.runtime package (for details, please read the API reference of that package). Note that the javassist.runtime package is the only package that classes modified by Javassist may need for running. The other Javassist classes are never used at runtime of the modified classes.</p><h2 id="4-6-Import"><a href="#4-6-Import" class="headerlink" title="4.6 Import"></a>4.6 Import</h2><p>All the class names in source code must be fully qualified (they must include package names). However, the java.lang package is an exception; for example, the Javassist compiler can resolve Object as well as java.lang.Object.</p><p>To tell the compiler to search other packages when resolving a class name, call importPackage() in ClassPool. For example,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.importPackage(<span class="string">&quot;java.awt&quot;</span>);</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">CtField f = CtField.make(<span class="string">&quot;public Point p;&quot;</span>, cc);</span><br><span class="line">cc.addField(f);</span><br></pre></td></tr></table></figure><p>The seconde line instructs the compiler to import the java.awt package. Thus, the third line will not throw an exception. The compiler can recognize Point as java.awt.Point.</p><p>Note that importPackage() does not affect the get() method in ClassPool. Only the compiler considers the imported packages. The parameter to get() must be always a fully qualified name.</p><h2 id="4-7-Limitations"><a href="#4-7-Limitations" class="headerlink" title="4.7 Limitations"></a>4.7 Limitations</h2><p>In the current implementation, the Java compiler included in Javassist has several limitations with respect to the language that the compiler can accept. Those limitations are:</p><p>The new syntax introduced by J2SE 5.0 (including enums and generics) has not been supported. Annotations are supported by the low level API of Javassist. See the javassist.bytecode.annotation package (and also getAnnotations() in CtClass and CtBehavior). Generics are also only partly supported. See the latter section for more details.<br>Array initializers, a comma-separated list of expressions enclosed by braces { and }, are not available unless the array dimension is one.<br>Inner classes or anonymous classes are not supported. Note that this is a limitation of the compiler only. It cannot compile source code including an anonymous-class declaration. Javassist can read and modify a class file of inner/anonymous class.<br>Labeled continue and break statements are not supported.<br>The compiler does not correctly implement the Java method dispatch algorithm. The compiler may confuse if methods defined in a class have the same name but take different parameter lists.<br>For example,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(A a)</span> </span>&#123; .. &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span> </span>&#123; .. &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the compiled expression is x.foo(new C()), where x is an instance of X, the compiler may produce a call to foo(A) although the compiler can correctly compile foo((B)new C()).</p><p>The users are recommended to use # as the separator between a class name and a static method or field name. For example, in regular Java,<br>javassist.CtClass.intType.getName()<br>calls a method getName() on the object indicated by the static field intType in javassist.CtClass. In Javassist, the users can write the expression shown above but they are recommended to write:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javassist.CtClass#intType.getName()</span><br></pre></td></tr></table></figure><p>so that the compiler can quickly parse the expression.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;CtClass&lt;/code&gt;提供了方法以便于自省. Javassist 的自省能力和Java的反射API很像. CtClass 提供了getName(), getSuperclass(), getMethods()等方法. CtClass仍然提供了修改一个类定义</summary>
      
    
    
    
    <category term="Javasist" scheme="https://wangmingco.github.io/categories/Javasist/"/>
    
    
  </entry>
  
  <entry>
    <title>Javasist Class Loader</title>
    <link href="https://wangmingco.github.io/2019/05/03/JavaLibrary/Javasist%203%20Class%20loader/"/>
    <id>https://wangmingco.github.io/2019/05/03/JavaLibrary/Javasist%203%20Class%20loader/</id>
    <published>2019-05-03T12:15:00.000Z</published>
    <updated>2021-11-18T03:12:28.690Z</updated>
    
    <content type="html"><![CDATA[<p>If what classes must be modified is known in advance, the easiest way for modifying the classes is as follows:</p><ol><li>Get a CtClass object by calling ClassPool.get(),</li><li>Modify it, and</li><li>Call writeFile() or toBytecode() on that CtClass object to obtain a modified class file.<br>If whether a class is modified or not is determined at load time, the users must make Javassist collaborate with a class loader. Javassist can be used with a class loader so that bytecode can be modified at load time. The users of Javassist can define their own version of class loader but they can also use a class loader provided by Javassist.</li></ol><h2 id="3-1-The-toClass-method-in-CtClass"><a href="#3-1-The-toClass-method-in-CtClass" class="headerlink" title="3.1 The toClass method in CtClass"></a>3.1 The toClass method in CtClass</h2><p>CtClass 提供了一个便捷方法 toClass(), 该方法会将CtClass对象所代表的class通过当前线程的context 类加载器加载进虚拟机里. 在调用该方法之前, 调用者必须拥有权限, 否则会抛出 SecurityException 异常.</p><p>The CtClass provides a convenience method toClass(), which requests the context class loader for the current thread to load the class represented by the CtClass object. To call this method, the caller must have appropriate permission; otherwise, a SecurityException may be thrown.</p><p>The following program shows how to use toClass():</p><p>下面的程序展示了如何使用toClass().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool cp = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = cp.get(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        CtMethod m = cc.getDeclaredMethod(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">        m.insertBefore(<span class="string">&quot;&#123; System.out.println(\&quot;Hello.say():\&quot;); &#125;&quot;</span>);</span><br><span class="line">        Class c = cc.toClass();</span><br><span class="line">        Hello h = (Hello)c.newInstance();</span><br><span class="line">        h.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.main() 在Hello类的say()方法中插入了一个对 println() 的方法调用. 然后将修改过的Hello class构建一个实例出来, 接着调用该实例的say()方法.</p><p>Test.main() inserts a call to println() in the method body of say() in Hello. Then it constructs an instance of the modified Hello class and calls say() on that instance.</p><blockquote><p>注意, 上面的程序能运行成功取决于在toClass()执行之前, Hello class从来没有被加载过. 如果Hello已经被加载过的话, 在toClass() 加载修改过的Hello class之前,  JVM会先将原生的Hello class加载进来. 因此加载修改过的Hello class就会失败(抛出LinkageError 错误). 例如:</p></blockquote><p>Note that the program above depends on the fact that the Hello class is never loaded before toClass() is invoked. If not, the JVM would load the original Hello class before toClass() requests to load the modified Hello class. Hence loading the modified Hello class would be failed (LinkageError is thrown). For example, if main() in Test is something like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Hello orig = <span class="keyword">new</span> Hello();</span><br><span class="line">    ClassPool cp = ClassPool.getDefault();</span><br><span class="line">    CtClass cc = cp.get(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 方法的第一行首先将原生的Hello class加载了进来, 后续再调用 toClass() 就会抛出异常, 这是因为同一个类加载器不能同时加载俩个相同版本的Hello class.</p><p>then the original Hello class is loaded at the first line of main and the call to toClass() throws an exception since the class loader cannot load two different versions of the Hello class at the same time.</p><p>如果这个应用程序运行在一些如JBoss或者Tomcat的应用服务器桑, toClass() 直接使用context 类加载器 可能就不太正确了. 在上面的例子中, 你会看到一个未检查异常 ClassCastException 被抛出. 要避免这种异常, 你必须给 toClass() 一个合适的类加载器. 例如, 如果变量 bean 是你的session bean对象的话, 你可以采用下面的代码:</p><p>If the program is running on some application server such as JBoss and Tomcat, the context class loader used by toClass() might be inappropriate. In this case, you would see an unexpected ClassCastException. To avoid this exception, you must explicitly give an appropriate class loader to toClass(). For example, if bean is your session bean object, then the following code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ...;</span><br><span class="line">Class c = cc.toClass(bean.getClass().getClassLoader());</span><br></pre></td></tr></table></figure><p>上面的代码可以正确运行. 你应该将加载你程序的类加载器传递给toClass() (在上面的例子中, 是bean对象的class)</p><p>would work. You should give toClass() the class loader that has loaded your program (in the above example, the class of the bean object).</p><p><code>toClass()</code> 只是一个便捷方法. 如果你需要更复杂的功能, 你应该实现自己的类加载器.</p><p>toClass() is provided for convenience. If you need more complex functionality, you should write your own class loader.</p><h2 id="3-2-Class-loading-in-Java"><a href="#3-2-Class-loading-in-Java" class="headerlink" title="3.2 Class loading in Java"></a>3.2 Class loading in Java</h2><p>在Java中, 多个class loader是可以共存的, 每个ClassLoader都有它自己的命名空间. 不同的类加载器可以加载相同名称的不同的class. 加载进来的class被视为不一样的. 这个特性允许我们在同一个JVM运行包含相同名称的class的多个应用程序.</p><p>In Java, multiple class loaders can coexist and each class loader creates its own name space. Different class loaders can load different class files with the same class name. The loaded two classes are regarded as different ones. This feature enables us to run multiple application programs on a single JVM even if these programs include different classes with the same name.</p><blockquote><p>注意, JVM不允许动态重新加载class. 一旦一个类加载器已经加载了一个class, 那么在运行期, 就不允许该类加载器再去加载一个已经修改过的class. 因此当JVM已经加载了一个class之后, 就不允许再去修改该class的定义了. 但是, JDPA(Java Platform Debugger Architecture) 提供了一些工具可以帮助重新加载一个类. See Section 3.6.</p></blockquote><p>Note: The JVM does not allow dynamically reloading a class. Once a class loader loads a class, it cannot reload a modified version of that class during runtime. Thus, you cannot alter the definition of a class after the JVM loads it. However, the JPDA (Java Platform Debugger Architecture) provides limited ability for reloading a class. See Section 3.6.</p><p>如果相同的class 文件被不同的类加载器加载了, JVM就会创建俩个名称和定义相同的class. 但是这俩个class是被视为是不同的. 因为这俩个class是不同的, 一个class的实例是不允许赋值到另一个class的变量的. 在这俩个class之间的转换操作会失败, 同时抛出一个 ClassCastException.</p><p>If the same class file is loaded by two distinct class loaders, the JVM makes two distinct classes with the same name and definition. The two classes are regarded as different ones. Since the two classes are not identical, an instance of one class is not assignable to a variable of the other class. The cast operation between the two classes fails and throws a ClassCastException.</p><p>例如, 下面的代码片段抛出的异常.</p><p>For example, the following code snippet throws an exception:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader myLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">Class clazz = myLoader.loadClass(<span class="string">&quot;Box&quot;</span>);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line">Box b = (Box)obj;    <span class="comment">// this always throws ClassCastException.</span></span><br></pre></td></tr></table></figure><p>Box class 被俩个类加载器加载. 假设一个类加载器 CL将上面的代码片段的一个类. CL会将上述代码片段的MyClassLoader, Class, Object, and Box进行加载(除非CL被代理给了其他类加载器). 因此变量b的类型是Box 是被CL加载的. 然而,  myLoader 也加载了Box class. 变量obj指向的对象就是被myLoader加载的Box的实例. 因此最后语句就会抛出异常ClassCastException, 因为obj的class和变量b所引用的class不是同一个.</p><p>The Box class is loaded by two class loaders. Suppose that a class loader CL loads a class including this code snippet. Since this code snippet refers to MyClassLoader, Class, Object, and Box, CL also loads these classes (unless it delegates to another class loader). Hence the type of the variable b is the Box class loaded by CL. On the other hand, myLoader also loads the Box class. The object obj is an instance of the Box class loaded by myLoader. Therefore, the last statement always throws a ClassCastException since the class of obj is a different verison of the Box class from one used as the type of the variable b.</p><p>不同的类加载器构成了一个树结构. 除了bootstrap类加载器, 每个类加载器都有一个父加载器, which has normally loaded the class of that child class loader. 因为被请求加载的类可以被代理给这个层级中的其他类加载器, 因此一个class也许可以被不是你想使用的其他类加载器加载. 因此, 你希望加载类C的类加载器也许和实际加载类C的加载器不是同一个. 因此为了区分这俩个类加载器, 我们把前一个类加载器称为<code>the initiator of C</code>, 后一个类加载器称为<code>the real loader of C</code>.</p><p>Multiple class loaders form a tree structure. Each class loader except the bootstrap loader has a parent class loader, which has normally loaded the class of that child class loader. Since the request to load a class can be delegated along this hierarchy of class loaders, a class may be loaded by a class loader that you do not request the class loading. Therefore, the class loader that has been requested to load a class C may be different from the loader that actually loads the class C. For distinction, we call the former loader the initiator of C and we call the latter loader the real loader of C.</p><p>此外, 如果被请求加载类C的类加载器(<code>the initiator of C</code>)被代理给了父加载器PL, 那么类加载器CL也不会再起加载类C中依赖的任何其他的类. 类加载CL就不再是哪些类的initiator, 它的父加载器PL就成为了initiator, 然后PL负责去加载哪些类. 类C定义中指向的那些类将会被类C的真实加载器进行加载.</p><p>Furthermore, if a class loader CL requested to load a class C (the initiator of C) delegates to the parent class loader PL, then the class loader CL is never requested to load any classes referred to in the definition of the class C. CL is not the initiator of those classes. Instead, the parent class loader PL becomes their initiators and it is requested to load them. The classes that the definition of a class C referes to are loaded by the real loader of C.</p><p>下面看一个例子, 深入理解一下:</p><p>To understand this behavior, let’s consider the following example.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;    <span class="comment">// loaded by PL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// the initiator is L but the real loader is PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> upperLeft.x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// loaded by a class loader L</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> box.getBaseX(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设类<code>Window</code>是被类加载器<code>L</code>加载的. 那么类<code>Window</code>的initiator和真实加载器都是<code>L</code>. 因为<code>Window</code>定义里面指向了类<code>Box</code>, JVM还将事业<code>L</code>去加载类<code>Box</code>. 这里, 假设, <code>L</code>将加载动作委托给了父加载器<code>PL</code>. <code>Box</code>的initiator就是<code>L</code>, 但是真实加载器就成<code>PL</code>. 在这个例子中, <code>Point</code>的initiator就成了<code>PL</code>而不是<code>L</code>, 因为它和<code>Box</code>的真实加载器是一样的. 因此<code>L</code>从来都不会加载<code>Point</code>.</p><p>Suppose that a class Window is loaded by a class loader L. Both the initiator and the real loader of Window are L. Since the definition of Window refers to Box, the JVM will request L to load Box. Here, suppose that L delegates this task to the parent class loader PL. The initiator of Box is L but the real loader is PL. In this case, the initiator of Point is not L but PL since it is the same as the real loader of Box. Thus L is never requested to load Point.</p><p>Next, let’s consider a slightly modified example.</p><p>下面的例子对刚才进行了一些稍微的修改:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// the initiator is L but the real loader is PL</span></span><br><span class="line">    <span class="keyword">private</span> Point upperLeft, size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// loaded by a class loader L</span></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">widthIs</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        Point p = box.getSize();</span><br><span class="line">        <span class="keyword">return</span> w == p.getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在, <code>Window</code>的定义也指向了<code>Point</code>. 在这个例子中, 如果类加载器<code>L</code>要加载<code>Point</code>, 它必须也被代理给<code>PL</code>. 你必须避免有俩个类加载器俩次加载相同一个类. 这俩个类加载器中的一个必须代理给另一个.</p><p>Now, the definition of Window also refers to Point. In this case, the class loader L must also delegate to PL if it is requested to load Point. You must avoid having two class loaders doubly load the same class. One of the two loaders must delegate to the other.</p><p>当<code>Point</code>被加载的时候, 如果<code>L</code>没有被代理给<code>PL</code>, <code>widthIs()</code> 将会抛出一个<code>ClassCastException</code>. 因为<code>Box</code>的真实类加载器是<code>PL</code>, <code>Box</code>中关联的<code>Point</code>也会被<code>PL</code>加载. 因此, <code>getSize()</code>真实调用的实例是由<code>PL</code>加载的类<code>Point</code>产生的, 而<code>widthIs()</code>中的变量<code>p</code>是由<code>L</code>加载的类<code>Point</code>. JVM将他们视作俩个类型, 因此会因为类型不匹配抛出一个异常.</p><p>If L does not delegate to PL when Point is loaded, widthIs() would throw a ClassCastException. Since the real loader of Box is PL, Point referred to in Box is also loaded by PL. Therefore, the resulting value of getSize() is an instance of Point loaded by PL whereas the type of the variable p in widthIs() is Point loaded by L. The JVM regards them as distinct types and thus it throws an exception because of type mismatch.</p><p>这个行为看起来是有点不方便, 但是却很必须的. 看下面的代码:</p><p>This behavior is somewhat inconvenient but necessary. If the following statement:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = box.getSize();</span><br></pre></td></tr></table></figure><p>这就不会抛出异常, 写<code>Window</code>的程序员破坏了<code>Point</code>对象的封装. 例如, 被<code>PL</code>加载的类<code>Point</code>中有个字段<code>x</code>是私有的. 如果<code>L</code>加载下面程序描述的<code>Point</code>, <code>Window</code>类就可以直接访问<code>x</code>的值.</p><p>did not throw an exception, then the programmer of Window could break the encapsulation of Point objects. For example, the field x is private in Point loaded by PL. However, the Window class could directly access the value of x if L loads Point with the following definition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;    <span class="comment">// not private</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于Java类加载器的细节, 下面的文章会更优帮助:</p><p>For more details of class loaders in Java, the following paper would be helpful:</p><blockquote><p>Sheng Liang and Gilad Bracha, “Dynamic Class Loading in the Java Virtual Machine”,<br>ACM OOPSLA’98, pp.36-44, 1998.</p></blockquote><h2 id="3-3-Using-javassist-Loader"><a href="#3-3-Using-javassist-Loader" class="headerlink" title="3.3 Using javassist.Loader"></a>3.3 Using javassist.Loader</h2><p>Javassist 提供了一个类加载器<code>javassist.Loader</code>. 这个类加载器使用<code>javassist.ClassPool</code>对象来读取class文件.</p><p>Javassist provides a class loader javassist.Loader. This class loader uses a javassist.ClassPool object for reading a class file.</p><p>例如, <code>javassist.Loader</code> 可以用来加载被Javassist修改过的class.</p><p>For example, javassist.Loader can be used for loading a particular class modified with Javassist.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"><span class="keyword">import</span> test.Rectangle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     ClassPool pool = ClassPool.getDefault();</span><br><span class="line">     Loader cl = <span class="keyword">new</span> Loader(pool);</span><br><span class="line"></span><br><span class="line">     CtClass ct = pool.get(<span class="string">&quot;test.Rectangle&quot;</span>);</span><br><span class="line">     ct.setSuperclass(pool.get(<span class="string">&quot;test.Point&quot;</span>));</span><br><span class="line"></span><br><span class="line">     Class c = cl.loadClass(<span class="string">&quot;test.Rectangle&quot;</span>);</span><br><span class="line">     Object rect = c.newInstance();</span><br><span class="line">         :</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应用程序修改了类<code>test.Rectangle</code>. <code>test.Rectangle</code>的父类被设置为了<code>test.Point</code>. 然后应用程序将修改过的class加载, 最后创建出一个新的<code>test.Rectangle</code>实例出来.</p><p>This program modifies a class test.Rectangle. The superclass of test.Rectangle is set to a test.Point class. Then this program loads the modified class, and creates a new instance of the test.Rectangle class.</p><p>如果用户想要当class被加载后, 后台会自动修改class, 可以通过向<code>javassist.Loader</code>添加事件监听器来完成. 当类加载器加载类的时候会自动通知注册了的事件监听器. 事件监听器必须下面的接口.</p><p>If the users want to modify a class on demand when it is loaded, the users can add an event listener to a javassist.Loader. The added event listener is notified when the class loader loads a class. The event-listener class must implement the following interface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当通过调用<code>javassist.Loader</code>的<code>addTranslator()</code>向<code>javassist.Loader</code>添加完成事件监听器后, <code>start()</code>方法就会被调用. <code>onLoad()</code>方法会在<code>javassist.Loader</code>加载类之前被调用. 可以在<code>onLoad()</code> 方法中修改一个类的定义.</p><p>The method start() is called when this event listener is added to a javassist.Loader object by addTranslator() in javassist.Loader. The method onLoad() is called before javassist.Loader loads a class. onLoad() can modify the definition of the loaded class.</p><p>例如, 下面的事件监听器在class被加载之前全部被修改成<code>public</code>.</p><p>For example, the following event listener changes all classes to public classes just before they are loaded.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTranslator</span> <span class="keyword">implements</span> <span class="title">Translator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NotFoundException, CannotCompileException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CtClass cc = pool.get(classname);</span><br><span class="line">        cc.setModifiers(Modifier.PUBLIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意, <code>onLoad()</code>方法中不用调用<code>toBytecode()</code> 或者 <code>writeFile()</code> 方法, <code>javassist.Loader</code>会自动去调用那些方法.</p></blockquote><p>Note that onLoad() does not have to call toBytecode() or writeFile() since javassist.Loader calls these methods to obtain a class file.</p><p>To run an application class MyApp with a MyTranslator object, write a main class as following:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     Translator t = <span class="keyword">new</span> MyTranslator();</span><br><span class="line">     ClassPool pool = ClassPool.getDefault();</span><br><span class="line">     Loader cl = <span class="keyword">new</span> Loader();</span><br><span class="line">     cl.addTranslator(pool, t);</span><br><span class="line">     cl.run(<span class="string">&quot;MyApp&quot;</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To run this program, do:</p><p>运行程序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% java Main2 arg1 arg2...</span><br></pre></td></tr></table></figure><p>类<code>MyApp</code>和程序中其他的类都会被<code>MyTranslator</code>修改.</p><p>The class MyApp and the other application classes are translated by MyTranslator.</p><p>注意, 程序中像<code>MyApp</code>这样的类不能访问oader classes, 例如<code>Main2, MyTranslator, and ClassPool</code>, 因为它们是被不同的加载器加载的. 应用程序的类是被<code>javassist.Loader</code>而loader classes(例如<code>Main2</code>)是被Java默认的类加载器加载的.</p><p>Note that application classes like MyApp cannot access the loader classes such as Main2, MyTranslator, and ClassPool because they are loaded by different loaders. The application classes are loaded by javassist.Loader whereas the loader classes such as Main2 are by the default Java class loader.</p><p><code>javassist.Loader</code>搜索类的顺序和<code>java.lang.ClassLoader</code>不一样. <code>ClassLoader</code>首先会将加载动作委托给他们父加载器, 只有当父加载器找不到, <code>ClassLoader</code>自己才会去加载. 而<code>javassist.Loader</code> 在委托给父类加载器之前, 自己首先加载一遍. 直接委托父加载器加载只取决于</p><ul><li>在调用<code>ClassPool</code>对象的<code>get()</code>方法是没有找到搜索的类</li><li>或者通过<code>delegateLoadingOf()</code>设置指定由父加载器去进行加载.</li></ul><p>javassist.Loader searches for classes in a different order from java.lang.ClassLoader. ClassLoader first delegates the loading operations to the parent class loader and then attempts to load the classes only if the parent class loader cannot find them. On the other hand, javassist.Loader attempts to load the classes before delegating to the parent class loader. It delegates only if:</p><ul><li>the classes are not found by calling get() on a ClassPool object, or</li><li>the classes have been specified by using delegateLoadingOf() to be loaded by the parent class loader.</li></ul><p>这种搜索顺序允许Javassist 加载修改过的类. 一旦它由于某些原因找不到修改过的类, 它仍然会将搜索动作委托给父加载器进行加载. 一旦类被父加载器加载到了, 那么类中其他的类也会被父加载器进行加载, 因此这些被父加载器加载的类是永远也不是被修改过的. 回想一下前文介绍的, 在类<code>C</code>中包含的类也会被<code>C</code>的真实加载器进行加载. 如果你的程序加载修改过的类失败了, 你应该确认一下使用那些类的其他类是否也被<code>javassist.Loader</code>进行加载的.</p><p>This search order allows loading modified classes by Javassist. However, it delegates to the parent class loader if it fails to find modified classes for some reason. Once a class is loaded by the parent class loader, the other classes referred to in that class will be also loaded by the parent class loader and thus they are never modified. Recall that all the classes referred to in a class C are loaded by the real loader of C. If your program fails to load a modified class, you should make sure whether all the classes using that class have been loaded by javassist.Loader.</p><h2 id="3-4-Writing-a-class-loader"><a href="#3-4-Writing-a-class-loader" class="headerlink" title="3.4 Writing a class loader"></a>3.4 Writing a class loader</h2><p>A simple class loader using Javassist is as follows:</p><p>使用Javassist中的类加载器很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Call MyApp.main().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SampleLoader s = <span class="keyword">new</span> SampleLoader();</span><br><span class="line">        Class c = s.loadClass(<span class="string">&quot;MyApp&quot;</span>);</span><br><span class="line">        c.getDeclaredMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;)</span><br><span class="line">         .invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; args &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SampleLoader</span><span class="params">()</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">        pool = <span class="keyword">new</span> ClassPool();</span><br><span class="line">        pool.insertClassPath(<span class="string">&quot;./class&quot;</span>); <span class="comment">// MyApp.class must be there.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finds a specified class.</span></span><br><span class="line"><span class="comment">     * The bytecode for that class can be modified.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CtClass cc = pool.get(name);</span><br><span class="line">            <span class="comment">// modify the CtClass object here</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = cc.toBytecode();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CannotCompileException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类<code>MyApp</code>是一个应用程序. 执行程序之前, 首先要将该类放到<code>./class</code>目录下, 但是不能包含在类搜索路径里. 否则<code>MyApp.class</code>会被系统默认的类加载器进行加载(会被<code>SampleLoader</code>父加载器加载). 通过在构建器中调用 <code>insertClassPath()</code> 设置了路径的名称<code>./class</code>. 你也可以不用<code>./class</code>, 换一个其他的名称, 然后执行:</p><p>The class MyApp is an application program. To execute this program, first put the class file under the ./class directory, which must not be included in the class search path. Otherwise, MyApp.class would be loaded by the default system class loader, which is the parent loader of SampleLoader. The directory name ./class is specified by insertClassPath() in the constructor. You can choose a different name instead of ./class if you want. Then do as follows:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% java SampleLoader</span><br></pre></td></tr></table></figure><p>类加载器会从<code>./class/MyApp.class</code>加载类<code>MyApp</code>, 然后调用<code>MyApp.main()</code>方法.</p><p>The class loader loads the class MyApp (./class/MyApp.class) and calls MyApp.main() with the command line parameters.</p><p>这是使用<code>Javassist</code>最简单的方式. 然而, 如果你写了一个复杂的类加载器, 你必须熟悉java类加载机制的细节. 例如, 上面的应用程序将<code>MyApp</code>放到了与<code>SampleLoader</code>所属的不同的一个名称空间里, 因为这俩个类是由不同的类加载器进行加载的. 因此<code>MyApp</code>不能直接访问类<code>SampleLoader</code>.</p><p>This is the simplest way of using Javassist. However, if you write a more complex class loader, you may need detailed knowledge of Java’s class loading mechanism. For example, the program above puts the MyApp class in a name space separated from the name space that the class SampleLoader belongs to because the two classes are loaded by different class loaders. Hence, the MyApp class cannot directly access the class SampleLoader.</p><h2 id="3-5-Modifying-a-system-class"><a href="#3-5-Modifying-a-system-class" class="headerlink" title="3.5 Modifying a system class"></a>3.5 Modifying a system class</h2><p>系统类例如<code>java.lang.String</code>除了系统类加载器之外不能被其他的类加载加载. 因此, 上面提到的<code>SampleLoader</code>或者<code>javassist.Loader</code>在加载时不能修改系统的类.</p><p>The system classes like java.lang.String cannot be loaded by a class loader other than the system class loader. Therefore, SampleLoader or javassist.Loader shown above cannot modify the system classes at loading time.</p><p>但是如果你的程序想要修改系统类, 那么系统类必须被静态修改. 例如下面的程序在<code>java.lang.String</code>添加了一个字段<code>hiddenValue</code>:</p><p>If your application needs to do that, the system classes must be statically modified. For example, the following program adds a new field hiddenValue to java.lang.String:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">CtField f = <span class="keyword">new</span> CtField(CtClass.intType, <span class="string">&quot;hiddenValue&quot;</span>, cc);</span><br><span class="line">f.setModifiers(Modifier.PUBLIC);</span><br><span class="line">cc.addField(f);</span><br><span class="line">cc.writeFile(<span class="string">&quot;.&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个程序产生了一个文件<code>./java/lang/String.class</code>.</p><p>This program produces a file “./java/lang/String.class”.</p><p>To run your program MyApp with this modified String class, do as follows:</p><p>在<code>MyApp</code>中使用这个修改过的类<code>String</code>, 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% java -Xbootclasspath/p:. MyApp arg1 arg2...</span><br></pre></td></tr></table></figure><p>假设<code>MyApp</code>定义如下:</p><p>Suppose that the definition of MyApp is as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(String.class.getField(<span class="string">&quot;hiddenValue&quot;</span>).getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果修改过的<code>String</code>被正确地加载, <code>MyApp</code>会打印<code>hiddenValue</code>的值.</p><p>If the modified String class is correctly loaded, MyApp prints hiddenValue.</p><blockquote><p>注意, 应用程序使用这个技术在覆盖<code>rt.jar</code>中的系统类的时候不应该被部署, 否则会违反<code>Java 2 Runtime Environment binary code license</code> 授权.</p></blockquote><p>Note: Applications that use this technique for the purpose of overriding a system class in rt.jar should not be deployed as doing so would contravene the Java 2 Runtime Environment binary code license.</p><h2 id="3-6-Reloading-a-class-at-runtime"><a href="#3-6-Reloading-a-class-at-runtime" class="headerlink" title="3.6 Reloading a class at runtime"></a>3.6 Reloading a class at runtime</h2><p>如果JVM在运行时JPDA开启了, 类就可以动态重加载了. JVM加载一个类后, 旧版本的class可以被卸载, 新版本的class可以再次加载进来. 这样一来就完成了在运行期动态修改类. 但是, 新版本的类定义必须兼容旧版本的类定义. JVM不允许这俩个版本的类的schema发生改变. 他们必须拥有相同的方法和字段.</p><p>Javassist提供了一个工具类用于在运行期动态重加载. 更多的细节信息参考API文档<code>javassist.tools.HotSwapper</code>.</p><p>If the JVM is launched with the JPDA (Java Platform Debugger Architecture) enabled, a class is dynamically reloadable. After the JVM loads a class, the old version of the class definition can be unloaded and a new one can be reloaded again. That is, the definition of that class can be dynamically modified during runtime. However, the new class definition must be somewhat compatible to the old one. The JVM does not allow schema changes between the two versions. They have the same set of methods and fields.</p><p>Javassist provides a convenient class for reloading a class at runtime. For more information, see the API documentation of javassist.tools.HotSwapper.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;If what classes must be modified is known in advance, the easiest way for modifying the classes is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Get a CtClass</summary>
      
    
    
    
    <category term="Javasist" scheme="https://wangmingco.github.io/categories/Javasist/"/>
    
    
  </entry>
  
  <entry>
    <title>Javasist ClassPool</title>
    <link href="https://wangmingco.github.io/2019/05/02/JavaLibrary/Javasist%202%20ClassPool/"/>
    <id>https://wangmingco.github.io/2019/05/02/JavaLibrary/Javasist%202%20ClassPool/</id>
    <published>2019-05-02T12:15:00.000Z</published>
    <updated>2021-11-18T03:12:28.689Z</updated>
    
    <content type="html"><![CDATA[<p>A ClassPool object is a container of CtClass objects. Once a CtClass object is created, it is recorded in a ClassPool for ever. This is because a compiler may need to access the CtClass object later when it compiles source code that refers to the class represented by that CtClass.</p><p><code>ClassPool</code>对象是CtClass对象的集合. 一旦CtClass对象被创建出来, 它就会被永远地保存在ClassPool中. 这是因为编译器在编译源码的时候可能还需要访问这些CtClass对象.</p><p>For example, suppose that a new method getter() is added to a CtClass object representing Point class. Later, the program attempts to compile source code including a method call to getter() in Point and use the compiled code as the body of a method, which will be added to another class Line. If the CtClass object representing Point is lost, the compiler cannot compile the method call to getter(). Note that the original class definition does not include getter(). Therefore, to correctly compile such a method call, the ClassPool must contain all the instances of CtClass all the time of program execution.</p><p>例如, 向Point类的CtClass对象添加一个新的getter()方法. 然后程序将某段调用Point的getter()方法的源码片段进行编译, 然后将编译好的代码片段放到另外一个类里. 如果找不到代表Point的CtClass的话, 编译器就没办法编译对getter()方法的调用. 注意, 原先的class是不包含getter()方法的. 因此, 为了能正确进行编译, 在程序运行期间, ClassPool必须包含全部的CtClass实例.</p><h2 id="Avoid-out-of-memory"><a href="#Avoid-out-of-memory" class="headerlink" title="Avoid out of memory"></a>Avoid out of memory</h2><p>This specification of ClassPool may cause huge memory consumption if the number of CtClass objects becomes amazingly large (this rarely happens since Javassist tries to reduce memory consumption in various ways). To avoid this problem, you can explicitly remove an unnecessary CtClass object from the ClassPool. If you call detach() on a CtClass object, then that CtClass object is removed from the ClassPool. For example,</p><p>按照上文描述的那样, 如果CtClass实例数量飞速增长的话, ClassPool就有可能会引起巨大的内存消耗(但是实际上这种情况很少发生, 因此Javassist会通过多种方式减少内存消耗). 为了解决这种问题, 你可以显式地从ClassPool里面删除不需要的CtClass实例. 如果你在CtClass对象上调用detach()方法的, 该对象就会从ClassPool里面移除. 例如: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CtClass cc = ... ;</span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.detach();</span><br></pre></td></tr></table></figure><p>当 detach() 方法被调用之后, CtClass实例的其他方法就不再允许被调用. 但是你可以接着调用ClassPool的get()方法, 再获得一个相同class的新的CtClass实例. 如果你调用了<code>get()</code>方法, ClassPool会重新读取class 文件, 然后再创建一个新的CtClass对象.</p><p>You must not call any method on that CtClass object after detach() is called. However, you can call get() on ClassPool to make a new instance of CtClass representing the same class. If you call get(), the ClassPool reads a class file again and newly creates a CtClass object, which is returned by get().</p><p>另一种思路是再重新创建一个ClassPool, 然后将旧的那个舍弃掉. 如果旧的ClassPool被gc掉了, 那么原先ClassPool里的CtClass对象也都被gc掉了. 如果要创建一个新的ClassPool实例, 执行下面的代码即可:</p><p>Another idea is to occasionally replace a ClassPool with a new one and discard the old one. If an old ClassPool is garbage collected, the CtClass objects included in that ClassPool are also garbage collected. To create a new instance of ClassPool, execute the following code snippet:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// if needed, append an extra search path by appendClassPath()</span></span><br></pre></td></tr></table></figure><p>刚才创建的ClassPool的行为和通过调用ClassPool.getDefault()返回的默认ClassPool是一样的. 注意ClassPool.getDefault()是出于便捷目的而存在的一个单例工厂方法. ClassPool.getDefault() 会像上面那样创建一个ClassPool 对象, 然后作为单例存在, 一直复用它. 通过getDefault()返回的ClassPool并没有特殊的规则. getDefault() 只是一个快捷方法.</p><p>This creates a ClassPool object that behaves as the default ClassPool returned by ClassPool.getDefault() does. Note that ClassPool.getDefault() is a singleton factory method provided for convenience. It creates a ClassPool object in the same way shown above although it keeps a single instance of ClassPool and reuses it. A ClassPool object returned by getDefault() does not have a special role. getDefault() is a convenience method.</p><p>注意 new ClassPool(true) 是一个快捷构造器,  它只是构建了一个ClassPool对象, 然后将系统搜索路径添加到这上面. 该构造器方法和下面方法等同.<br>Note that new ClassPool(true) is a convenient constructor, which constructs a ClassPool object and appends the system search path to it. Calling that constructor is equivalent to the following code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = <span class="keyword">new</span> ClassPool();</span><br><span class="line">cp.appendSystemPath();  <span class="comment">// or append another path by appendClassPath()</span></span><br></pre></td></tr></table></figure><h2 id="Cascaded-ClassPools"><a href="#Cascaded-ClassPools" class="headerlink" title="Cascaded ClassPools"></a>Cascaded ClassPools</h2><p>如果应用程序是运行在一个web 服务器上, 那么就有可能需要创建多个ClassPool实例. 每个class Loader都需要创建一个ClassPool实例. 在这种背景下, 就需要通过ClassPool的构造器创建ClassPool实例, 而不能再通过getDefault()方法获得了.</p><p>If a program is running on a web application server, creating multiple instances of ClassPool might be necessary; an instance of ClassPool should be created for each class loader (i.e. container). The program should create a ClassPool object by not calling getDefault() but a constructor of ClassPool.</p><p>Multiple ClassPool objects can be cascaded like java.lang.ClassLoader. For example,</p><p>多个ClassPool对象可以像java.lang.ClassLoader那样呗级联起来. 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool parent = ClassPool.getDefault();</span><br><span class="line">ClassPool child = <span class="keyword">new</span> ClassPool(parent);</span><br><span class="line">child.insertClassPath(<span class="string">&quot;./classes&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果child.get()方法被调用, child ClassPool首先将该请求委托给上一级ClassPool. 如果上一级ClassPool没有找到目标class文件, 那么child ClassPool就会尝试在./classes目录里查找class文件.</p><p>If child.get() is called, the child ClassPool first delegates to the parent ClassPool. If the parent ClassPool fails to find a class file, then the child ClassPool attempts to find a class file under the ./classes directory.</p><p>如果 child.childFirstLookup 被设置为true的话, child ClassPool就会首先尝试尝试查找class文件, 找不到再去上一级ClassPool中查找. 例如:</p><p>If child.childFirstLookup is true, the child ClassPool attempts to find a class file before delegating to the parent ClassPool. For example,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool parent = ClassPool.getDefault();</span><br><span class="line">ClassPool child = <span class="keyword">new</span> ClassPool(parent);</span><br><span class="line">child.appendSystemPath();         <span class="comment">// the same class path as the default one.</span></span><br><span class="line">child.childFirstLookup = <span class="keyword">true</span>;    <span class="comment">// changes the behavior of the child.</span></span><br></pre></td></tr></table></figure><h2 id="Changing-a-class-name-for-defining-a-new-class"><a href="#Changing-a-class-name-for-defining-a-new-class" class="headerlink" title="Changing a class name for defining a new class"></a>Changing a class name for defining a new class</h2><p>A new class can be defined as a copy of an existing class. The program below does that:</p><p>一个新的class可以通过从已经存在的class的副本中制作出来. 例如L</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">cc.setName(<span class="string">&quot;Pair&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面的程序首先获得了Point对应的CtClass对象. 然后它调用setName()设置了一个新的名称Pair. setName()被调用之后, CtClass对象中的所有该class 名称都从Point转换成了Pair. 但是class 定义的其他部分并没有变.</p><p>This program first obtains the CtClass object for class Point. Then it calls setName() to give a new name Pair to that CtClass object. After this call, all occurrences of the class name in the class definition represented by that CtClass object are changed from Point to Pair. The other part of the class definition does not change.</p><p>注意CtClass的setName()也会改变ClassPool中的记录. 从实现角度来说, 一个CLassPool对象就是CtClass对象的一个hash表. setName()也会将hash表中和CtClass对象关联的key也更改掉. key从原先的class名称换到了新的class名称.<br>Note that setName() in CtClass changes a record in the ClassPool object. From the implementation viewpoint, a ClassPool object is a hash table of CtClass objects. setName() changes the key associated to the CtClass object in the hash table. The key is changed from the original class name to the new class name.</p><p>因此, 如果再次调用ClassPool的get(“Point”)方法, 再也不会返回cc所指向的CtClass对象. ClassPool会再次读取Point.class文件, 然后构建出一个新的Point的CtClass对象出来. 这厮因为和Point名称关联的CtClass对象已经不复存在了. 例如:</p><p>Therefore, if get(“Point”) is later called on the ClassPool object again, then it never returns the CtClass object that the variable cc refers to. The ClassPool object reads a class file Point.class again and it constructs a new CtClass object for class Point. This is because the CtClass object associated with the name Point does not exist any more. See the followings:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">CtClass cc1 = pool.get(<span class="string">&quot;Point&quot;</span>);   <span class="comment">// cc1 is identical to cc.</span></span><br><span class="line">cc.setName(<span class="string">&quot;Pair&quot;</span>);</span><br><span class="line">CtClass cc2 = pool.get(<span class="string">&quot;Pair&quot;</span>);    <span class="comment">// cc2 is identical to cc.</span></span><br><span class="line">CtClass cc3 = pool.get(<span class="string">&quot;Point&quot;</span>);   <span class="comment">// cc3 is not identical to cc.</span></span><br></pre></td></tr></table></figure><p>cc1和cc2指向的是和cc指向的相同的对象, 而cc3则不是. 注意, cc.setName(“Pair”) 方法执行之后, cc和cc1指向CtClass对象也代表着Pair class.<br>cc1 and cc2 refer to the same instance of CtClass that cc does whereas cc3 does not. Note that, after cc.setName(“Pair”) is executed, the CtClass object that cc and cc1 refer to represents the Pair class.</p><p>ClassPool对象被用来维持class和CtClass对象之间的一对一映射. 在同一个ClassPool中, Javassist从不允许俩个不同的CtClass对象代表同一个class. 对于程序转换来说, 这是一个非常有意义的特性.</p><p>The ClassPool object is used to maintain one-to-one mapping between classes and CtClass objects. Javassist never allows two distinct CtClass objects to represent the same class unless two independent ClassPool are created. This is a significant feature for consistent program transformation.</p><p>如果你有俩个ClassPool对象, 那么你可以从每个ClassPool里面获得一个相同的class的CtClass对象. 你可以通过修改不同的CtClass对象生成不同版本的class.</p><p>If you have two ClassPool objects, then you can obtain, from each ClassPool, a distinct CtClass object representing the same class file. You can differently modify these CtClass objects to generate different versions of the class.</p><h2 id="Renaming-a-frozen-class-for-defining-a-new-class"><a href="#Renaming-a-frozen-class-for-defining-a-new-class" class="headerlink" title="Renaming a frozen class for defining a new class"></a>Renaming a frozen class for defining a new class</h2><p>一旦一个CtClass对象通过writeFile() or toBytecode()方法转换成一个class, Javassist就不允许CtClass对象再次修改了. 因此, 当代表Point的CtClass对象被转换成一个class之后, 你就不能再通过设置setName()的方式来获取一个Point的副本Pair了. 例如下面的代码, 是不合法的.</p><p>Once a CtClass object is converted into a class file by writeFile() or toBytecode(), Javassist rejects further modifications of that CtClass object. Hence, after the CtClass object representing Point class is converted into a class file, you cannot define Pair class as a copy of Point since executing setName() on Point is rejected. The following code snippet is wrong:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.setName(<span class="string">&quot;Pair&quot;</span>);    <span class="comment">// wrong since writeFile() has been called.</span></span><br></pre></td></tr></table></figure><p>To avoid this restriction, you should call getAndRename() in ClassPool. For example,</p><p>对于这种限制, 你应该调用ClassPool的getAndRename()方法, 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">cc.writeFile();</span><br><span class="line">CtClass cc2 = pool.getAndRename(<span class="string">&quot;Point&quot;</span>, <span class="string">&quot;Pair&quot;</span>);</span><br></pre></td></tr></table></figure><p>getAndRename()被调用之后, ClassPool首先读取Point.class, 然后创建出一个代表Point class的CtClass对象. 在存储ClassPool的hash表之前, 它将CtClass名称从Point重新命名为Pair. 因此, getAndRename() 可以再writeFile() or toBytecode()被调用之后 再次调用.</p><p>If getAndRename() is called, the ClassPool first reads Point.class for creating a new CtClass object representing Point class. However, it renames that CtClass object from Point to Pair before it records that CtClass object in a hash table. Thus getAndRename() can be executed after writeFile() or toBytecode() is called on the the CtClass object representing Point class.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A ClassPool object is a container of CtClass objects. Once a CtClass object is created, it is recorded in a ClassPool for ever. This is b</summary>
      
    
    
    
    <category term="Javasist" scheme="https://wangmingco.github.io/categories/Javasist/"/>
    
    
  </entry>
  
  <entry>
    <title>Javasist Reading and writing bytecode</title>
    <link href="https://wangmingco.github.io/2019/05/01/JavaLibrary/Javasist%201%20Reading%20and%20writing%20bytecode/"/>
    <id>https://wangmingco.github.io/2019/05/01/JavaLibrary/Javasist%201%20Reading%20and%20writing%20bytecode/</id>
    <published>2019-05-01T12:15:00.000Z</published>
    <updated>2021-11-18T03:12:28.689Z</updated>
    
    <content type="html"><![CDATA[<p><code>Javassist</code> is a class library for dealing with Java bytecode. Java bytecode is stored in a binary file called a class file. Each class file contains one Java class or interface.</p><p><code>Javassist</code> 是一个用于处理 Java 字节码的类库, Java 字节码被存储在一个后缀为 class 的二进制文件中. 每个 class 文件包含一个 Java 类或者 Java 接口.</p><p>The class Javassist.CtClass is an abstract representation of a class file. A CtClass (compile-time class) object is a handle for dealing with a class file. The following program is a very simple example:</p><p><code>Javassist.CtClass</code> 类是对 class 文件的一个抽象表示. 一个 <code>CtClass</code> (compile-time class) 对象处理一个 class 文件. 下面的程序是一个非常简单的示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.get(<span class="string">&quot;test.Rectangle&quot;</span>);</span><br><span class="line">cc.setSuperclass(pool.get(<span class="string">&quot;test.Point&quot;</span>));</span><br><span class="line">cc.writeFile();</span><br></pre></td></tr></table></figure><p>This program first obtains a ClassPool object, which controls bytecode modification with Javassist. The ClassPool object is a container of CtClass object representing a class file. It reads a class file on demand for constructing a CtClass object and records the constructed object for responding later accesses. To modify the definition of a class, the users must first obtain from a ClassPool object a reference to a CtClass object representing that class. get() in ClassPool is used for this purpose. In the case of the program shown above, the CtClass object representing a class test.Rectangle is obtained from the ClassPool object and it is assigned to a variable cc. The ClassPool object returned by getDefault() searches the default system search path.</p><p>这个程序首先获得了一个<code>ClassPool</code>对象, 该对象在 Javassist 中用于控制字节码的修改. <code>ClassPool</code> 对象是一个 <code>CtClass</code>对象的容器. <code>ClassPool</code>将读取的class文件构建出<code>CtClass</code>对象, 同时将构建出来的对象缓存起来, 以便后期访问. <code>ClassPool</code>的<code>get()</code>方法正是出于上述目的. 在上面的代码中, 从<code>ClassPool</code>得到的<code>CtClass</code>对象表示的是一个<code>test.Rectangle</code>对象, 然后将该对象分配给了一个变量<code>cc</code>. <code>getDefault()</code>方法会从默认的系统搜索路径中进行搜索, 然后返回<code>ClassPool</code>对象.</p><p>From the implementation viewpoint, ClassPool is a hash table of CtClass objects, which uses the class names as keys. get() in ClassPool searches this hash table to find a CtClass object associated with the specified key. If such a CtClass object is not found, get() reads a class file to construct a new CtClass object, which is recorded in the hash table and then returned as the resulting value of get().</p><p>从实现上来说, <code>ClassPool</code>是一个<code>CtClass</code>对象的哈希表, 将class的名称作为key. <code>ClassPool</code>中的 <code>get()</code> 方法会根据指定的key对整个哈希表进行搜索找到一个<code>CtClass</code>对象. 如果搜索不到的话, <code>get()</code>方法会尝试读取class文件, 然后构造出一个新的<code>CtClass</code>对象, 将新的<code>CtClass</code>对象缓存后, 再返回出去.</p><p>The CtClass object obtained from a ClassPool object can be modified (details of how to modify a CtClass will be presented later). In the example above, it is modified so that the superclass of test.Rectangle is changed into a class test.Point. This change is reflected on the original class file when writeFile() in CtClass() is finally called.</p><p>从<code>ClassPool</code>中拿到的<code>CtClass</code>对象可以对其进行修改(修改<code>CtClass</code>的细节会在后续的文章中讲解). 在上面的例子中, 通过<code>CtClass</code>的修改就将<code>test.Rectangle</code>的父类修改了<code>test.Point</code>. 如果我们调用了<code>CtClass</code>的<code>writeFile()</code>方法, 这个修改也对原先的class文件生效了.</p><p>writeFile() translates the CtClass object into a class file and writes it on a local disk. Javassist also provides a method for directly obtaining the modified bytecode. To obtain the bytecode, call toBytecode():</p><p><code>writeFile()</code>将<code>CtClass</code>对象转换成一个class文件, 然后将该文件写到本地磁盘上. Javassist还提供了用于直接获得修改后的字节码的方法-<code>toBytecode()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b = cc.toBytecode();</span><br></pre></td></tr></table></figure><p>You can directly load the CtClass as well:</p><p>你也可以直接将Class加载进去.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = cc.toClass();</span><br></pre></td></tr></table></figure><p>toClass() requests the context class loader for the current thread to load the class file represented by the CtClass. It returns a java.lang.Class object representing the loaded class. For more details, please see this section below.</p><p><code>toClass()</code>方法 会使用当前线程的context class loader将<code>CtClass</code>内的字节码加载进JVM里, 然后返回一个<code>java.lang.Class</code>对象.</p><h2 id="Defining-a-new-class"><a href="#Defining-a-new-class" class="headerlink" title="Defining a new class"></a>Defining a new class</h2><p>To define a new class from scratch, makeClass() must be called on a ClassPool.</p><p>从头开始定义一个新的class, 必须调用<code>ClassPool</code>的<code>makeClass()</code> 方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">CtClass cc = pool.makeClass(<span class="string">&quot;Point&quot;</span>);</span><br></pre></td></tr></table></figure><p>This program defines a class Point including no members. Member methods of Point can be created with factory methods declared in CtNewMethod and appended to Point with addMethod() in CtClass.</p><p>上面的程序定义了一个没有任何成员的名称为<code>Point</code>的class. 可以通过<code>CtNewMethod</code>里声明的一些工厂方法为<code>Point</code>类生成一些方法, 然后通过调用<code>CtClass</code>的<code>addMethod()</code>方法, 将这些新生成的方法加到<code>Point</code>class里面去.</p><p>makeClass() cannot create a new interface; makeInterface() in ClassPool can do. Member methods in an interface can be created with abstractMethod() in CtNewMethod. Note that an interface method is an abstract method.</p><p><code>makeClass()</code> 不能创建新的接口, 但是可以使用<code>ClassPool</code>中的<code>makeInterface()</code>创建一个新的接口. 接口中的方法可以使用<code>CtNewMethod</code>的<code>abstractMethod()</code>方法创建出来. 注意, 一个接口方法就是一个抽象方法.</p><h2 id="Frozen-classes"><a href="#Frozen-classes" class="headerlink" title="Frozen classes"></a>Frozen classes</h2><p>If a CtClass object is converted into a class file by writeFile(), toClass(), or toBytecode(), Javassist freezes that CtClass object. Further modifications of that CtClass object are not permitted. This is for warning the developers when they attempt to modify a class file that has been already loaded since the JVM does not allow reloading a class.</p><p>如果<code>CtClass</code>对象通过<code>writeFile(), toClass(), or toBytecode()</code>等方式转换成一个class文件, Javassist会将<code>CtClass</code>对象冻结. 被冻结的<code>CtClass</code>对象不允许再次修改. 这是为了警告开发者, 他们尝试修改一个已经被load的class文件, 而JVM不允许重新加载class.</p><p>A frozen CtClass can be defrost so that modifications of the class definition will be permitted. For example,</p><p>被冻结的<code>CtClass</code>也可以进行解冻, 解冻之后就可以继续就那些修改了, 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClasss cc = ...;</span><br><span class="line">    :</span><br><span class="line">cc.writeFile();</span><br><span class="line">cc.defrost();</span><br><span class="line">cc.setSuperclass(...);    <span class="comment">// OK since the class is not frozen.</span></span><br></pre></td></tr></table></figure><p>After defrost() is called, the CtClass object can be modified again.</p><p>当<code>defrost()</code>方法被调用之后, <code>CtClass</code>就可以再次修改了.</p><p>If ClassPool.doPruning is set to true, then Javassist prunes the data structure contained in a CtClass object when Javassist freezes that object. To reduce memory consumption, pruning discards unnecessary attributes (attribute_info structures) in that object. For example, Code_attribute structures (method bodies) are discarded. Thus, after a CtClass object is pruned, the bytecode of a method is not accessible except method names, signatures, and annotations. The pruned CtClass object cannot be defrost again. The default value of ClassPool.doPruning is false.</p><p>如果<code>ClassPool.doPruning</code>被设置为true的话, 当Javassist冻结<code>CtClass</code>对象的时候, 会对其内部的数据结构进行精简. 为了减少内存消耗, pruning精简了<code>attribute_info</code>结构里不必要的属性. 例如方法体里面的<code>Code_attribute</code>结构就会被舍弃掉. 因此一旦<code>CtClass</code>对象被精简之后, 方法除了名称, 签名, 注解等其他信息都不可再被访问到. 而且被精简过后的<code>CtClass</code>对象也不可以再被解冻. <code>ClassPool.doPruning</code>默认值是false.</p><p>To disallow pruning a particular CtClass, stopPruning() must be called on that object in advance:</p><p>如果将要设置某个特殊的<code>CtClass</code>不允许精简, 必选提前调用<code>CtClasss</code>对象的<code>stopPruning()</code>方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CtClasss cc = ...;</span><br><span class="line">cc.stopPruning(<span class="keyword">true</span>);</span><br><span class="line">    :</span><br><span class="line">cc.writeFile();                             <span class="comment">// convert to a class file.</span></span><br><span class="line"><span class="comment">// cc is not pruned.</span></span><br></pre></td></tr></table></figure><p>The CtClass object cc is not pruned. Thus it can be defrost after writeFile() is called.</p><p>上面<code>CtClass</code>对象没有被精简, 因此当它调用了<code>writeFile()</code>方法之后, 还可以被解冻.</p><blockquote><p>Note: While debugging, you might want to temporarily stop pruning and freezing and write a modified class file to a disk drive. debugWriteFile() is a convenient method for that purpose. It stops pruning, writes a class file, defrosts it, and turns pruning on again (if it was initially on).</p></blockquote><blockquote><p>注意: 在调试阶段, 你也许想要临时地停止精简和冻结操作, 然后将一个修改过的class文件写到磁盘中, 此时你可以调用<code>debugWriteFile()</code>方法. 它首先停止精简操作, 然后对class文件执行写入操作, 最后再解冻, 最后回复精简状态.</p></blockquote><h2 id="Class-search-path"><a href="#Class-search-path" class="headerlink" title="Class search path"></a>Class search path</h2><p>The default ClassPool returned by a static method ClassPool.getDefault() searches the same path that the underlying JVM (Java virtual machine) has. If a program is running on a web application server such as JBoss and Tomcat, the ClassPool object may not be able to find user classes since such a web application server uses multiple class loaders as well as the system class loader. In that case, an additional class path must be registered to the ClassPool. Suppose that pool refers to a ClassPool object:</p><p><code>ClassPool.getDefault()</code>返回的默认的<code>ClassPool</code>是基于JVM的path上面搜索得到的. 如果应用程序是运行在一个web应用服务器上(例如JBoss或者Tomcat), <code>ClassPool</code>对象可能会找不到用户定义的class, 因为web应用服务器可能会使用多个class Loader. 在这种情况下可以向<code>ClassPool</code>上注册一个新的class path.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="keyword">this</span>.getClass()));</span><br></pre></td></tr></table></figure><p>This statement registers the class path that was used for loading the class of the object that this refers to. You can use any Class object as an argument instead of this.getClass(). The class path used for loading the class represented by that Class object is registered.</p><p>You can register a directory name as the class search path. For example, the following code adds a directory /usr/local/javalib to the search path:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">pool.insertClassPath(<span class="string">&quot;/usr/local/javalib&quot;</span>);</span><br></pre></td></tr></table></figure><p>The search path that the users can add is not only a directory but also a URL:</p><p>用户能添加的search path不仅仅是目录, 还可以添加URL:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool pool = ClassPool.getDefault();</span><br><span class="line">ClassPath cp = <span class="keyword">new</span> URLClassPath(<span class="string">&quot;www.javassist.org&quot;</span>, <span class="number">80</span>, <span class="string">&quot;/java/&quot;</span>, <span class="string">&quot;org.javassist.&quot;</span>);</span><br><span class="line">pool.insertClassPath(cp);</span><br></pre></td></tr></table></figure><p>这个应用程序添加了一个<code>http://www.javassist.org:80/java/</code>url到search path上. 只有当搜索属于<code>org.javassist</code>这个包下的类的时候, 才会去这个URL上进行搜索. 例如当加载<code>org.javassist.test.Main</code>类时, 它的class 文件将会从<code>http://www.javassist.org:80/java/org/javassist/test/Main.class</code>上进行加载.</p><p>This program adds “<a href="http://www.javassist.org/java/&quot;">http://www.javassist.org:80/java/&quot;</a> to the class search path. This URL is used only for searching classes belonging to a package org.javassist. For example, to load a class org.javassist.test.Main, its class file will be obtained from:</p><p><a href="http://www.javassist.org/java/org/javassist/test/Main.class">http://www.javassist.org:80/java/org/javassist/test/Main.class</a></p><p>Furthermore, you can directly give a byte array to a ClassPool object and construct a CtClass object from that array. To do this, use ByteArrayClassPath. For example,</p><p>另外, 你可以直接向<code>ClassPool</code>对象里指定一个byte数组, <code>ClassPool</code>会从这个byte数组里构建出一个<code>CtClass</code>对象. 想要使用这种方案, 可以用<code>ByteArrayClassPath</code>, 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = ClassPool.getDefault();</span><br><span class="line"><span class="keyword">byte</span>[] b = a <span class="keyword">byte</span> array;</span><br><span class="line">String name = <span class="class"><span class="keyword">class</span> <span class="title">name</span></span>;</span><br><span class="line">cp.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(name, b));</span><br><span class="line">CtClass cc = cp.get(name);</span><br></pre></td></tr></table></figure><p>The obtained CtClass object represents a class defined by the class file specified by b. The ClassPool reads a class file from the given ByteArrayClassPath if get() is called and the class name given to get() is equal to one specified by name.</p><p>获取到的<code>CtClass</code>对象就是从<code>b</code>数组里定义出来的. 当<code>get()</code>方法被调用的时候, <code>ClassPool</code>会从给定的<code>ByteArrayClassPath</code>里读取出一个class文件, class名称就是参数name.</p><p>If you do not know the fully-qualified name of the class, then you can use makeClass() in ClassPool:<br>如果你不知道class的全限定名称, 你可以使用<code>ClassPool</code>的<code>makeClass()</code>方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPool cp = ClassPool.getDefault();</span><br><span class="line">InputStream ins = an input stream <span class="keyword">for</span> reading a <span class="class"><span class="keyword">class</span> <span class="title">file</span></span>;</span><br><span class="line">CtClass cc = cp.makeClass(ins);</span><br></pre></td></tr></table></figure><p>makeClass() returns the CtClass object constructed from the given input stream. You can use makeClass() for eagerly feeding class files to the ClassPool object. This might improve performance if the search path includes a large jar file. Since a ClassPool object reads a class file on demand, it might repeatedly search the whole jar file for every class file. makeClass() can be used for optimizing this search. The CtClass constructed by makeClass() is kept in the ClassPool object and the class file is never read again.</p><p><code>makeClass()</code>方法会从给定的输入流里构建出一个<code>CtClass</code>对象. 你可以使用<code>makeClass()</code>方法先一步地将class文件传给给<code>ClassPool</code>对象. 如果在搜索路径里面有一个特别大的jar文件时, 这有可能提升性能. 因为<code>ClassPool</code>在后台读取class文件时, 有可能将每一个class文件都在jar文件中匹配一遍. <code>makeClass()</code> 可以优化类似的搜索. 通过<code>makeClass()</code>构建出来的<code>CtClass</code>可以缓存在<code>ClassPool</code>里, 当再次查找相同class时, 就不需要再次去class path上搜索了.</p><p>The users can extend the class search path. They can define a new class implementing ClassPath interface and give an instance of that class to insertClassPath() in ClassPool. This allows a non-standard resource to be included in the search path.</p><p>用户可以拓展class search path. 他们可以将<code>ClassPath</code>接口实现类的实例通过<code>insertClassPath()</code>方法添加到<code>ClassPool</code>里. 这就可以允许一个非标准的资源路径加载到search path上.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Javassist&lt;/code&gt; is a class library for dealing with Java bytecode. Java bytecode is stored in a binary file called a class file. E</summary>
      
    
    
    
    <category term="Javasist" scheme="https://wangmingco.github.io/categories/Javasist/"/>
    
    
  </entry>
  
  <entry>
    <title>CGLib 动态代理 原理解析</title>
    <link href="https://wangmingco.github.io/2019/04/28/zhihu/CGLib/"/>
    <id>https://wangmingco.github.io/2019/04/28/zhihu/CGLib/</id>
    <published>2019-04-28T11:34:00.000Z</published>
    <updated>2021-11-24T02:59:27.088Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/63272694">CGLib 动态代理 原理解析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/63272694&quot;&gt;CGLib 动态代理 原理解析&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaIO原理剖析之 网络IO</title>
    <link href="https://wangmingco.github.io/2019/04/14/zhihu/java_net_io/"/>
    <id>https://wangmingco.github.io/2019/04/14/zhihu/java_net_io/</id>
    <published>2019-04-14T10:28:00.000Z</published>
    <updated>2021-11-24T03:00:20.112Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/62166017">JavaIO原理剖析之 网络IO</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/62166017&quot;&gt;JavaIO原理剖析之 网络IO&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>JDK 动态代理实现与原理</title>
    <link href="https://wangmingco.github.io/2019/03/25/zhihu/java_dyn_proxy/"/>
    <id>https://wangmingco.github.io/2019/03/25/zhihu/java_dyn_proxy/</id>
    <published>2019-03-25T06:48:00.000Z</published>
    <updated>2021-11-24T03:00:17.457Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/60288881">JDK 动态代理实现与原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60288881&quot;&gt;JDK 动态代理实现与原理&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>图解 LinkedBlockingQueue实现原理</title>
    <link href="https://wangmingco.github.io/2019/02/13/zhihu/LinkedBlockingQueue/"/>
    <id>https://wangmingco.github.io/2019/02/13/zhihu/LinkedBlockingQueue/</id>
    <published>2019-02-13T03:51:00.000Z</published>
    <updated>2021-11-24T03:00:33.226Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/56579882">图解 LinkedBlockingQueue实现原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56579882&quot;&gt;图解 LinkedBlockingQueue实现原理&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="知乎" scheme="https://wangmingco.github.io/categories/%E7%9F%A5%E4%B9%8E/"/>
    
    
  </entry>
  
</feed>

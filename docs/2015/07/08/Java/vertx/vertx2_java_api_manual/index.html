<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
   <!-- google 爬取标记 -->
   <meta name="google-site-verification" content="aH2bcbMuMlpfF61i9p--iBH54wvMywGXfWg8U6RpxFA" />
   <!-- bing 爬取标记 -->
   <meta name="msvalidate.01" content="CBAB9A13FF212142D6C250D9C0D31F28" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Vertx 2 Java Api Manaual | 向南</title>
  <meta name="description" content="Writing Verticles正如我们在手册里描述的那样,一个verticle是就是一个Vert.x的执行单元 再重复一下，Vert.x是一个Verticle容器，而且Vert.x确保一个verticle实例永远不会被多个线程并发执行。你可以使用Vert.x支持的所有的语言来编写Verticle，同时Vert.x支持并发执行同一个verticle文件实例出多个Verticle实例。 在Ver">
<meta property="og:type" content="article">
<meta property="og:title" content="Vertx 2 Java Api Manaual">
<meta property="og:url" content="https://wangmingco.github.io/2015/07/08/Java/vertx/vertx2_java_api_manual/index.html">
<meta property="og:site_name" content="向南">
<meta property="og:description" content="Writing Verticles正如我们在手册里描述的那样,一个verticle是就是一个Vert.x的执行单元 再重复一下，Vert.x是一个Verticle容器，而且Vert.x确保一个verticle实例永远不会被多个线程并发执行。你可以使用Vert.x支持的所有的语言来编写Verticle，同时Vert.x支持并发执行同一个verticle文件实例出多个Verticle实例。 在Ver">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2015-07-08T08:20:00.000Z">
<meta property="article:modified_time" content="2022-06-27T06:18:24.467Z">
<meta property="article:author" content="向南">
<meta property="article:tag" content="vertx2">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://wangmingco.github.io/2015/07/08/Java/vertx/vertx2_java_api_manual/index.html">
  
    <link rel="alternate" href="/atom.xml" title="向南" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/wangmingco" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">向南</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Coder</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/wangmingco" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://gitee.com/wangmingco" target="_blank" title="Gitee" data-toggle=tooltip data-placement=top><i class="icon icon-gitee"></i></a></li>
        
        <li><a href="https://weibo.com/wangmingco" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://www.zhihu.com/people/wangmingco" target="_blank" title="Zhihu" data-toggle=tooltip data-placement=top><i class="icon icon-zhihu"></i></a></li>
        
        <li><a href="https://www.douban.com/people/xxxyy/" target="_blank" title="Douban" data-toggle=tooltip data-placement=top><i class="icon icon-douban"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Groovy/">Groovy</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">125</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NoSql/">NoSql</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PYTHON2/">PYTHON2</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/awk/">awk</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/haskell/">haskell</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E6%96%87/">杂文</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">11</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-%E4%B8%89%E6%96%B9%E5%BA%93/" rel="tag">Java 三方库</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaSE/" rel="tag">JavaSE</a><span class="tag-list-count">27</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javasist/" rel="tag">Javasist</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memcached/" rel="tag">Memcached</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEG-js/" rel="tag">PEG.js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/asm/" rel="tag">asm</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmh/" rel="tag">jmh</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jol/" rel="tag">jol</a><span class="tag-list-count">24</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">jvm</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vertx2/" rel="tag">vertx2</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vertx3/" rel="tag">vertx3</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Java-%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 13.82px;">Java 三方库</a> <a href="/tags/JavaSE/" style="font-size: 14px;">JavaSE</a> <a href="/tags/JavaScript/" style="font-size: 13.45px;">JavaScript</a> <a href="/tags/Javasist/" style="font-size: 13.27px;">Javasist</a> <a href="/tags/Memcached/" style="font-size: 13px;">Memcached</a> <a href="/tags/MongoDB/" style="font-size: 13.18px;">MongoDB</a> <a href="/tags/Netty/" style="font-size: 13.55px;">Netty</a> <a href="/tags/PEG-js/" style="font-size: 13px;">PEG.js</a> <a href="/tags/React/" style="font-size: 13px;">React</a> <a href="/tags/Redis/" style="font-size: 13.18px;">Redis</a> <a href="/tags/asm/" style="font-size: 13.27px;">asm</a> <a href="/tags/jmh/" style="font-size: 13.64px;">jmh</a> <a href="/tags/jol/" style="font-size: 13.91px;">jol</a> <a href="/tags/jvm/" style="font-size: 13.73px;">jvm</a> <a href="/tags/maven/" style="font-size: 13px;">maven</a> <a href="/tags/mysql/" style="font-size: 13.36px;">mysql</a> <a href="/tags/vertx2/" style="font-size: 13.09px;">vertx2</a> <a href="/tags/vertx3/" style="font-size: 13.27px;">vertx3</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">35</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
              </p>
              <p class="item-title">
                <a href="/2022/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/sql/" class="title">SQL 手册</a>
              </p>
              <p class="item-date">
                <time datetime="2022-06-19T16:00:00.000Z" itemprop="datePublished">2022-06-20</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%9D%82%E6%96%87/">杂文</a>
              </p>
              <p class="item-title">
                <a href="/2022/06/01/%E6%9D%82%E6%96%87/duizhang/" class="title">对账</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-31T16:00:00.000Z" itemprop="datePublished">2022-06-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
              </p>
              <p class="item-title">
                <a href="/2022/04/12/%E5%89%8D%E7%AB%AF/REACT%20%E8%AF%AD%E6%B3%95/" class="title">React 学习</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-12T02:21:00.000Z" itemprop="datePublished">2022-04-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java/">Java</a>
              </p>
              <p class="item-title">
                <a href="/2022/01/10/Java/jvm/centos%E7%BC%96%E8%AF%91openjdk/" class="title">Centos7 编译调试 OpenJDK11</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-09T16:00:00.000Z" itemprop="datePublished">2022-01-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2021/12/09/html/bj_baidu/" class="title">北京景点</a>
              </p>
              <p class="item-date">
                <time datetime="2021-12-09T07:40:00.000Z" itemprop="datePublished">2021-12-09</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-Java/vertx/vertx2_java_api_manual" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Vertx 2 Java Api Manaual
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2015/07/08/Java/vertx/vertx2_java_api_manual/" class="article-date">
	  <time datetime="2015-07-08T08:20:00.000Z" itemprop="datePublished">2015-07-08</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/vertx2/" rel="tag">vertx2</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2015/07/08/Java/vertx/vertx2_java_api_manual/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <script src="/assets/asciinema-player.js"></script><link rel="stylesheet" type="text/css" href="/assets/asciinema-player.css" />
<h1 id="Writing-Verticles"><a href="#Writing-Verticles" class="headerlink" title="Writing Verticles"></a>Writing Verticles</h1><p>正如我们在手册里描述的那样,一个verticle是就是一个Vert.x的执行单元</p>
<p>再重复一下，Vert.x是一个Verticle容器，而且Vert.x确保一个verticle实例永远不会被多个线程并发执行。你可以使用Vert.x支持的所有的语言来编写Verticle，同时Vert.x支持并发执行同一个verticle文件实例出多个Verticle实例。</p>
<p>在Vert.x中，你所编写的所有代码其实都是在Verticle实例中运行。</p>
<p>对于一个简单的任务，你可以直接编写原生verticle，然后在命令行中直接运行它们，但是在大部分情况中你都应该将verticle打包成Vert.x module。</p>
<blockquote>
<p>原生verticle，指的就是一个单独的没有打包进module的文件或者类,例如<code>verticle1.class, verticle2.java, verticle3.rb, verticle4.groovy</code></p>
</blockquote>
<p>现在让我们编写一个简单的原生verticle：</p>
<p>我们将编写一个简单的TCP echo服务器。这个服务器仅仅接受网络连接，然后将接收到的数据进行输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.vertx.java.core.Handler;</span><br><span class="line"><span class="keyword">import</span> org.vertx.java.core.net.NetSocket;</span><br><span class="line"><span class="keyword">import</span> org.vertx.java.core.streams.Pump;</span><br><span class="line"><span class="keyword">import</span> org.vertx.java.platform.Verticle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Verticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vertx.createNetServer().connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> NetSocket socket)</span> </span>&#123;</span><br><span class="line">        Pump.createPump(socket, socket).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).listen(<span class="number">1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在运行它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx run Server.java</span><br></pre></td></tr></table></figure>
<p>现在服务器运行起来了，然后通过telnet连接它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost</span><br></pre></td></tr></table></figure>
<p>注意，你通过回车发送出去的数据是如何输出的</p>
<p>现在，你已经编写了第一个verticle。</p>
<p>也许你已经注意到了，你并没有手动将<code>.java</code>文件编译成<code>.class</code>文件。Vert.x知道如何直接”运行”<code>.java</code>文件，其实在Vert.x内部会自动编译该源文件。</p>
<p>每一个java vertivle都必须继承<code>org.vertx.java.deploy.Verticle</code>,然后必须重载<code>start</code>方法，当verticle启动时，Vert.x会自动调用该方法。</p>
<h2 id="Asynchronous-start"><a href="#Asynchronous-start" class="headerlink" title="Asynchronous start"></a>Asynchronous start</h2><p>假设现在有一个Verticle——<code>v1</code>不得不在<code>start()</code>方法中，完成一些异步的操作，或者启动一些其他verticle，在这些操作完成之前，<code>v1</code>一直都应该是未完成状态。</p>
<p>在这种情况下，你的verticle可以实现<code>start()</code>方法的异步版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> Future&lt;Void&gt; startedResult)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// For example - deploy some other verticle</span></span><br><span class="line">  container.deployVerticle(<span class="string">&quot;foo.js&quot;</span>, <span class="keyword">new</span> AsyncResultHandler&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;String&gt; deployResult)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (deployResult.succeeded()) &#123;</span><br><span class="line">        startedResult.setResult(<span class="keyword">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startedResult.setFailure(deployResult.cause());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Verticle-clean-up"><a href="#Verticle-clean-up" class="headerlink" title="Verticle clean-up"></a>Verticle clean-up</h2><p>当verticle停止后，其内部的<code>Servers, clients, event bus handlers and timers</code>会自动关闭或者取消掉，当某个verticle停止时，你如果想要进行一些其他的清理逻辑，你可以自己实现<code>stop()</code>方法，那么当该verticle被解除部署时，该方法就会被自动调用</p>
<h2 id="The-container-object"><a href="#The-container-object" class="headerlink" title="The container object"></a>The container object</h2><p>每一个verticle实例都有一个称为<code>container</code>的成员变量。<code>container</code>表示的是它运行所在的Verticle的一个视图。</p>
<p><code>container</code>对象定义了部署和解除部署verticle和module的方法，同时还允许设置环境变量和一个可访问的logger</p>
<h2 id="The-vertx-object"><a href="#The-vertx-object" class="headerlink" title="The vertx object"></a>The vertx object</h2><p>每一个verticle实例都含有一个<code>vertx</code>实例变量。该变量提供了访问Vert.x核心API的能力。在Vert.x中，你要使用该核心API完成大部分工作，例如<code>TCP, HTTP, file system access, event bus, timers</code>等等。</p>
<h2 id="Getting-Configuration-in-a-Verticle"><a href="#Getting-Configuration-in-a-Verticle" class="headerlink" title="Getting Configuration in a Verticle"></a>Getting Configuration in a Verticle</h2><p>你可以像下例这样在命令行中通过<code>-conf</code>选项向module或者verticle传递配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx runmod com.mycompany~my-mod~1.0 -conf myconf.json</span><br></pre></td></tr></table></figure>

<p>或者向一个原生vertile传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx run foo.js -conf myconf.json</span><br></pre></td></tr></table></figure>

<p><code>-conf</code>参数是一个包含JSON对象的文本文件名字。</p>
<p>通过调用verticle成员变量<code>contailner</code>的<code>config()</code>方法该配置就成功启用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JsonObject config = container.config();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Config is &quot;</span> + config);</span><br></pre></td></tr></table></figure>

<p><code>config()</code>返回一个<code>org.vertx.java.core.json.JsonObject</code>实例，该实例代表一个json对象。</p>
<p>无论部署什么语言实现的verticle，对于配置verticle的方式是一致的。</p>
<h2 id="Logging-from-a-Verticle"><a href="#Logging-from-a-Verticle" class="headerlink" title="Logging from a Verticle"></a>Logging from a Verticle</h2><p>每个verticle实例都有一个属于它自己的logger。可以通过调用<code>container</code>实例的<code>logger()</code>方法获取<code>logger</code>对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = container.logger();</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">&quot;I am logging something&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>The logger is an instance of the class org.vertx.java.core.logging.Logger and has the following methods;</p>
<p><code>logger</code>是<code>org.vertx.java.core.logging.Logger</code>的实例,该实例拥有下列方法：</p>
<ul>
<li><code>trace</code></li>
<li><code>debug</code></li>
<li><code>info</code></li>
<li><code>warn</code></li>
<li><code>error</code></li>
<li><code>fatal</code></li>
</ul>
<p><code>logger</code>产生的日志存储到系统临时目录的<code>vertx.log</code>文件中,在linux中的临时目录是<code>\tmp</code>.</p>
<p>更多关于配置logging方法的信息，参考主手册</p>
<h2 id="Accessing-environment-variables-from-a-Verticle"><a href="#Accessing-environment-variables-from-a-Verticle" class="headerlink" title="Accessing environment variables from a Verticle"></a>Accessing environment variables from a Verticle</h2><p>你可以通过调用<code>container</code>对象的<code>env()</code>方法来访问环境变量</p>
<h2 id="Causing-the-container-to-exit"><a href="#Causing-the-container-to-exit" class="headerlink" title="Causing the container to exit"></a>Causing the container to exit</h2><p><code>container</code>的<code>exit()</code>方法会干净地关闭掉Vert.x实例</p>
<h1 id="Deploying-and-Undeploying-Verticles-Programmatically"><a href="#Deploying-and-Undeploying-Verticles-Programmatically" class="headerlink" title="Deploying and Undeploying Verticles Programmatically"></a>Deploying and Undeploying Verticles Programmatically</h1><p>你可以在一个verticle中通过编程方式对其他verticle进行部署和解除部署。任何通过该方式部署的verticle都有能力看见主verticle的资源(classes, scripts 或者其他文件)</p>
<h2 id="Deploying-a-simple-verticle"><a href="#Deploying-a-simple-verticle" class="headerlink" title="Deploying a simple verticle"></a>Deploying a simple verticle</h2><p>如果想要通过程序的方式部署一个verticle，只需要调用<code>container</code>变量里的<code>deployVerticle</code>方法。</p>
<p>下面的例子就部署了一个verticle实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.deployVerticle(main);</span><br></pre></td></tr></table></figure>

<p><code>main</code>是被部署的Verticle的名字(java源文件名称或者类的FQCN)</p>
<p>具体参考主手册的<a href="">running Vert.x</a>章节</p>
<h2 id="Deploying-Worker-Verticles"><a href="#Deploying-Worker-Verticles" class="headerlink" title="Deploying Worker Verticles"></a>Deploying Worker Verticles</h2><p><code>deployVerticle</code>方法部署的是标准verticle,如果你想要部署工作者verticle,你可以使用<code>deployWorkerVerticle</code>方法，这俩个方法的参数一致。</p>
<h2 id="Deploying-a-module-programmatically"><a href="#Deploying-a-module-programmatically" class="headerlink" title="Deploying a module programmatically"></a>Deploying a module programmatically</h2><p>你可以采用下面的方式部署一个<code>module</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.deployModule(<span class="string">&quot;io.vertx~mod-mailer~2.0.0-beta1&quot;</span>, config);</span><br></pre></td></tr></table></figure>

<p>程序会根据指定的配置部署一个<code>io.vertx~mod-mailer~2.0.0-beta1</code>的<code>module</code>实例。</p>
<h2 id="Passing-configuration-to-a-verticle-programmatically"><a href="#Passing-configuration-to-a-verticle-programmatically" class="headerlink" title="Passing configuration to a verticle programmatically"></a>Passing configuration to a verticle programmatically</h2><p>我们也可以将JSON配置传递给通过程序部署的verticle。在部署的verticle内部，配置可以被<code>config()</code>方法访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JsonObject config = <span class="keyword">new</span> JsonObject();</span><br><span class="line">config.putString(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;wibble&quot;</span>);</span><br><span class="line">config.putBoolean(<span class="string">&quot;bar&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">container.deployVerticle(<span class="string">&quot;foo.ChildVerticle&quot;</span>, config);</span><br></pre></td></tr></table></figure>

<p>然后，在<code>ChildVerticle</code>中，你能通过<code>config()</code>方法访问刚才的配置</p>
<h2 id="Using-a-Verticle-to-co-ordinate-loading-of-an-application"><a href="#Using-a-Verticle-to-co-ordinate-loading-of-an-application" class="headerlink" title="Using a Verticle to co-ordinate loading of an application"></a>Using a Verticle to co-ordinate loading of an application</h2><p>如果你的应用程序是由多个verticle组成，并且希望都当应用程序启动的时候，所有的verticle都能启动起来，那么你可以使用一个单独的verticle来管理应用程序的配置，而且由该verticle启动剩余的全部verticle。</p>
<p>下例中，我们创建了一个<code>AppStarter</code>verticle.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Application config</span></span><br><span class="line">JsonObject appConfig = container.config();</span><br><span class="line"></span><br><span class="line">JsonObject verticle1Config = appConfig.getObject(<span class="string">&quot;verticle1_conf&quot;</span>);</span><br><span class="line">JsonObject verticle2Config = appConfig.getObject(<span class="string">&quot;verticle2_conf&quot;</span>);</span><br><span class="line">JsonObject verticle3Config = appConfig.getObject(<span class="string">&quot;verticle3_conf&quot;</span>);</span><br><span class="line">JsonObject verticle4Config = appConfig.getObject(<span class="string">&quot;verticle4_conf&quot;</span>);</span><br><span class="line">JsonObject verticle5Config = appConfig.getObject(<span class="string">&quot;verticle5_conf&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the verticles that make up the app</span></span><br><span class="line"></span><br><span class="line">container.deployVerticle(<span class="string">&quot;verticle1.js&quot;</span>, verticle1Config);</span><br><span class="line">container.deployVerticle(<span class="string">&quot;verticle2.rb&quot;</span>, verticle2Config);</span><br><span class="line">container.deployVerticle(<span class="string">&quot;foo.Verticle3&quot;</span>, verticle3Config);</span><br><span class="line">container.deployWorkerVerticle(<span class="string">&quot;foo.Verticle4&quot;</span>, verticle4Config);</span><br><span class="line">container.deployWorkerVerticle(<span class="string">&quot;verticle5.js&quot;</span>, verticle5Config, <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>然后我们创建一个<code>config.json</code>配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;verticle1_conf&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;wibble&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;verticle2_conf&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="number">1234</span>,</span><br><span class="line">        <span class="string">&quot;shoe_size&quot;</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="string">&quot;pi&quot;</span>: <span class="number">3.14159</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;verticle3_conf&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;strange&quot;</span>: <span class="keyword">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;verticle4_conf&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;george&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;verticle5_conf&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;tel_no&quot;</span>: <span class="string">&quot;123123123&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将<code>AppStarter</code>设置为module里的主要verticle, 接着你就可以通过下面的例子来启动整个应用程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx runmod com.mycompany~my-mod~1.0 -conf config.json</span><br></pre></td></tr></table></figure>

<p>如果你的应用程序是非常庞大的，而且是由多个module组成，那么你仍然可以使用相同的技术来实现。</p>
<p>通常，你也许会选择一种脚本语言(<code>JavaScript, Groovy, Ruby or Python</code>)作为你的启动verticle实现语言，那些语言通常会比java更好地支持JSON，因此你可以在启动verticle中非常友好地持有整个JSON配置。</p>
<h2 id="Specifying-number-of-instances"><a href="#Specifying-number-of-instances" class="headerlink" title="Specifying number of instances"></a>Specifying number of instances</h2><p>当你部署一个verticle时，默认地会只部署一个verticle实例。由于verticle实例是单线程执行的，因此这意味着，这种方式只会用到一个服务器核心。</p>
<p>Vert.x通过部署多个verticle实例来达到拓展（并发运行）</p>
<p>如果你想在程序中部署多个verticle或者module，你可以像下面这样，指定部署实例的数量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.deployVerticle(<span class="string">&quot;foo.ChildVerticle&quot;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>或者使用下面这种方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.deployModule(&quot;io.vertx~some-mod~1.0&quot;, 10);</span><br></pre></td></tr></table></figure>


<h2 id="Getting-Notified-when-Deployment-is-complete"><a href="#Getting-Notified-when-Deployment-is-complete" class="headerlink" title="Getting Notified when Deployment is complete"></a>Getting Notified when Deployment is complete</h2><p>verticle的部署实际上是以异步方式运行的，也许是在<code>deployVerticle</code>或者<code>deployModule</code>方法返回之后才完成部署.如果你想当部署完成之后获得通知，那么你可以向 <code>deployVerticle</code>或者<code>deployModule</code>方法传递一个handler，以便当部署完成时获得通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">container.deployVerticle(<span class="string">&quot;foo.ChildVerticle&quot;</span>, <span class="keyword">new</span> AsyncResultHandler&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;String&gt; asyncResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncResult.succeeded()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The verticle has been deployed, deployment ID is &quot;</span> + asyncResult.result());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            asyncResult.cause().printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当部署完成时，<code>handler</code>会获得一个<code>AsyncResult</code>实例. 你可以通过调用<code>AsyncResult</code>对象的<code>succeeded()</code> 和 <code>failed()</code>方法来观察部署是否正确完成了。</p>
<p><code>result()</code>方法提供异步操作的结果,在这个例子中，部署的结果是部署ID,如果你以后要接触部署verticle或者module的话，你就需要这个部署ID了。</p>
<p><code>cause()</code>方法提供了失败原因</p>
<h2 id="Undeploying-a-Verticle-or-Module"><a href="#Undeploying-a-Verticle-or-Module" class="headerlink" title="Undeploying a Verticle or Module"></a>Undeploying a Verticle or Module</h2><p>如果verticle被解除部署后，那么通过该verticle部署的verticle或者module，以及它们所有子代，都会被自动解除部署，所以在大多数情况下，你不需要手动地去解除部署一个verticle。然而，当你真的需要手动去解除部署verticle或者module时，你可以通过调用<code>undeployVerticle</code>或者<code>undeployModule</code>的方法来实现(这俩个方法需要传递部署ID)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.undeployVerticle(deploymentID);</span><br></pre></td></tr></table></figure>

<p>你也可以向这俩个方法中传递一个handler，那么当解除部署完成后，你就会得到一个通知</p>
<h2 id="Scaling-your-application"><a href="#Scaling-your-application" class="headerlink" title="Scaling your application"></a>Scaling your application</h2><p>一个verticle实例总是单线程的(工作者verticle除外),这意味着一个verticle实例最多使用一个服务器核心</p>
<p>为了能够利用多核优势，你需要部署多个verticle实例。需要部署的具体数量就取决于你的应用程序了，例如有多少个verticle(不是verticle实例)以及verticle的类型都是什么。</p>
<p>你可以通过程序方式部署多个verticle实例，或者在命令行上通过<code>-instances</code>选项指定部署的数量</p>
<h1 id="The-Event-Bus"><a href="#The-Event-Bus" class="headerlink" title="The Event Bus"></a>The Event Bus</h1><p><code>event bus</code>充当着Vert.x的”神经系统”</p>
<p>它允许vertivle能够相互通信，不管这些verticle是否是同一种语言实现，或者是否是在同一个<code>Vert.x</code>实例里。</p>
<p>It even allows client side JavaScript running in a browser to communicate on the same event bus. (More on that later).</p>
<p>它甚至允许运行在浏览器里的同一个event bus的JavaScript形式的verticle相互交互</p>
<p><code>event bus</code>形成了一个横跨多个服务器节点以及多个浏览器的分布式的端对端的消息系统,</p>
<p><code>event bus</code>的API是相当简单的. 它基本上只涉及了<code>registering handlers</code>, <code>unregistering handlers</code> 和 <code>sending/publishing messages</code>.</p>
<h2 id="The-Theory"><a href="#The-Theory" class="headerlink" title="The Theory"></a>The Theory</h2><h3 id="Addressing"><a href="#Addressing" class="headerlink" title="Addressing"></a>Addressing</h3><p>我们通过<code>event bus</code>向一个地址发送<code>Message</code>.</p>
<p>在Vert.x中不需要担心是否会使用到复杂的寻址方案. 在Vert.x中，地址就是一个简单的合法字符串。Vert.x的地址还使用了一些<code>scheme</code>,例如使用<code>.</code>分割命名空间区间。</p>
<p>一些合法的地址例如：<code>europe.news.feed1</code>, <code>acme.games.pacman</code>, <code>sausages</code>, and <code>X</code></p>
<h3 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h3><p>我们使用<code>handler</code>从<code>event bus</code>中接收消息——向一个地址注册一个<code>handler</code>。</p>
<p>无论是否是同一个<code>verticle</code>中的<code>handler</code>都可以向相同的地址进行注册。<code>verticle</code>中的同一个<code>handler</code>也可以注册到不同的地址上</p>
<h3 id="Publish-subscribe-messaging"><a href="#Publish-subscribe-messaging" class="headerlink" title="Publish / subscribe messaging"></a>Publish / subscribe messaging</h3><p><code>event bus</code>也支持消息发布——消息会被发布到某一个地址上.消息发布意味着：将消息发布给在某个地址上注册的全部<code>handler</code>。这和<code>publish/subscribe</code>消息模式很像。</p>
<h3 id="Point-to-point-and-Request-Response-messaging"><a href="#Point-to-point-and-Request-Response-messaging" class="headerlink" title="Point to point and Request-Response messaging"></a>Point to point and Request-Response messaging</h3><p><code>event bus</code>支持点对点消息传送.消息会被发送到一个地址上。Vert.x然后会在该地址上的N个handler中选择一个,然后将消息传递给被选择的handler。如果某个地址上注册了多个handler，Vert.x会根据一个不是很严格的循环算法来选取一个。</p>
<p>在点对点传送消息的情况中，当发送消息时，可以指定一个可选的回复handler。当接受者接受到一个消息后，同时该Message被处理后，接受者可以选择是否回应该消息。如果接受者选择回应该消息，那么reply handler会被调用。</p>
<p>当发送者接收到消息回应后，发送者还可以选择接着回应。这种模式可以永远重复下去，Vert.x还支持在这俩个verticle中创建一个会话。这种通用的消息模式称为<code>Request-Response</code>模式。</p>
<h3 id="Transient"><a href="#Transient" class="headerlink" title="Transient"></a>Transient</h3><p><code>event bus</code>消息都具有瞬时性，当<code>event bus</code>全部或者部分失败后，那就有可能丢失一部分消息。如果你的应用程序不允许出现消息丢失，那么你应该将你的<code>handler</code>编码成<code>idempotent</code>，同时当<code>event bus</code>恢复后，你的sender再尝试回应消息。</p>
<p>如果你想要持久有你的消息，你可以使用<code>persistent work queue module</code></p>
<h3 id="Types-of-messages"><a href="#Types-of-messages" class="headerlink" title="Types of messages"></a>Types of messages</h3><p>在<code>event bus</code>上传递的消息可以是一个简单的字符串，一个数字，一个boolean，或者是<code>Vert.x Buffer</code> 或者<code>JSON</code>消息。</p>
<p>但是我们强烈建议你在不同的verticle中通过JSON消息进行通信。JSON可以在Vert.x支持的语言中轻松地创建和解析。</p>
<h3 id="Event-Bus-API"><a href="#Event-Bus-API" class="headerlink" title="Event Bus API"></a>Event Bus API</h3><h3 id="Registering-and-Unregistering-Handlers"><a href="#Registering-and-Unregistering-Handlers" class="headerlink" title="Registering and Unregistering Handlers"></a>Registering and Unregistering Handlers</h3><p>下例展示了如何在<code>test.address</code>上注册一个消息<code>handler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventBus eb = vertx.eventBus();</span><br><span class="line"></span><br><span class="line">Handler&lt;Message&gt; myHandler = <span class="keyword">new</span> Handler&lt;Message&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I received a message &quot;</span> + message.body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eb.registerHandler(<span class="string">&quot;test.address&quot;</span>, myHandler);</span><br></pre></td></tr></table></figure>

<p><code>myHandler</code>会接受到所有发送到<code>test.address</code>地址上的消息。</p>
<p><code>Message</code>是一个泛型类，已经指定的消息类型有：<code>Message&lt;Boolean&gt;, Message&lt;Buffer&gt;, Message&lt;byte[]&gt;, Message&lt;Byte&gt;, Message&lt;Character&gt;, Message&lt;Double&gt;, Message&lt;Float&gt;, Message&lt;Integer&gt;, Message&lt;JsonObject&gt;, Message&lt;JsonArray&gt;, Message&lt;Long&gt;, Message&lt;Short&gt; and Message&lt;String&gt;</code></p>
<p>如果你确定接受到的消息都是同一种类型，那么你可以在handler上使用指定类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Handler&lt;Message&lt;String&gt;&gt; myHandler = <span class="keyword">new</span> Handler&lt;Message&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        String body = message.body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>registerHandler</code>方法返回的是<code>event bus</code>自身。我们提供了一个流畅的API，因此你可以将多个调用连接在一起。</p>
<p>当你向某个地址中注册一个handler，同时处于一个集群中，那该注册过程就需要耗费一点时间来在整个集群中的进行传播。如果你想<code>handler</code>注册成功后获得通知，那么你可以向<code>registerHandler</code>方法的第三个参数中指定另一个handler。当集群中的所有节点都收到向某个地址注册<code>handler</code>信息之后，那么第三个参数<code>handler</code>就会被调用,然后你就会收到handler注册完成的通知了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eb.registerHandler(<span class="string">&quot;test.address&quot;</span>, myHandler, <span class="keyword">new</span> AsyncResultHandler&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;Void&gt; asyncResult)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The handler has been registered across the cluster ok? &quot;</span> + asyncResult.succeeded());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>解除<code>handler</code>注册也是非常简单的，你只需要向<code>unregisterHandler</code>方法传递注册地址和已经注册上的那个<code>handler</code>对象就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eb.unregisterHandler(<span class="string">&quot;test.address&quot;</span>, myHandler);</span><br></pre></td></tr></table></figure>

<p>一个<code>handler</code>可以向相同的或者不同的地址上注册多次，因此为了在handler解除注册时，能够确定handler的唯一性，在解除注册时你需要同时指定要被解除的<code>handler</code>对象和注册地址</p>
<p>和注册一样，当你在一个集群环境中解除handler注册，这个过程需要耗费一些时间，以便整个集群都会收到该解除注册通知。同样的你如果想要当解除注册完成之后获得通知，<code>registerHandler</code>给这个函数增加一个第三个参数就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eb.unregisterHandler(<span class="string">&quot;test.address&quot;</span>, myHandler, <span class="keyword">new</span> AsyncResultHandler&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;Void&gt; asyncResult)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The handler has been unregistered across the cluster ok? &quot;</span> + asyncResult.succeeded());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果你想要你的handler存在于整个verticle的生命周期内，那么你就没有必要显式地去对该handler进行解除注册，当verticle停止的时候，Vert.x会自动对其进行解除注册</p>
<h2 id="Publishing-messages"><a href="#Publishing-messages" class="headerlink" title="Publishing messages"></a>Publishing messages</h2><p>发布一个消息也是非常简单的，你只需要指定一个发布地址，然后在指定发布的内容就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eb.publish(<span class="string">&quot;test.address&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个消息会发布给在该地址上注册的所有handler。</p>
<h2 id="Sending-messages"><a href="#Sending-messages" class="headerlink" title="Sending messages"></a>Sending messages</h2><p>通过<code>send</code>发送消息，那么目标地址上只有一个handler进行消息接受。这是一种点对点的发送消息模式。选取handler同样采用了一种不是很严格的<code>round-robin</code>算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eb.send(<span class="string">&quot;test.address&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Replying-to-messages"><a href="#Replying-to-messages" class="headerlink" title="Replying to messages"></a>Replying to messages</h2><p>当你接受到一个消息后，你可能需要对该消息进行回应，这种模式称为<code>request-response</code></p>
<p>当你<code>send</code>一个消息时，你将一个回应<code>handler</code>作为第三个参数。当接受者接收到消息后，他们可以调用<code>Message</code>的<code>reply</code>方法来回应消息。当<code>reply</code>方法被调用的时候，它会将回复消息发送者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Handler&lt;Message&lt;String&gt;&gt; myHandler = <span class="keyword">new</span> Handler&lt;Message&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I received a message &quot;</span> + message.body);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do some stuff</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now reply to it</span></span><br><span class="line"></span><br><span class="line">        message.reply(<span class="string">&quot;This is a reply&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eb.registerHandler(<span class="string">&quot;test.address&quot;</span>, myHandler);</span><br></pre></td></tr></table></figure>

<p>The sender:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eb.send(<span class="string">&quot;test.address&quot;</span>, <span class="string">&quot;This is a message&quot;</span>, <span class="keyword">new</span> Handler&lt;Message&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I received a reply &quot;</span> + message.body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>发送空的<code>reply</code>或者<code>null reply</code>都是合法的。</p>
<p>The replies themselves can also be replied to so you can create a dialog between two different verticles consisting of multiple rounds.</p>
<h2 id="Specifying-timeouts-for-replies"><a href="#Specifying-timeouts-for-replies" class="headerlink" title="Specifying timeouts for replies"></a>Specifying timeouts for replies</h2><p>如果你在发送消息时指定了一个reply handler, 但是却一直得不到回复响应，那么那么该handler永远都不会被解除注册。</p>
<p>为了解决这个问题，你可以指定一个<code>Handler&lt;AsyncResult&lt;Message&gt;&gt;</code>作为<code>reply handler</code>，然后再设置一个超时时间。如果在超时之前，你收到了消息的reply，那么该<code>AsyncResult</code>的<code>handler</code>方法就会被调用。如果超时前一直都得不到<code>reply</code>，那么该<code>handler</code>就会自动被解除注册，同时<code>new Handler&lt;AsyncResult&lt;Message&lt;String&gt;&gt;&gt;()</code>也会被调用，但是<code>AsyncResult</code>会包含一个失败的状态，你可以在这种状态下做一些特殊处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eb.sendWithTimeout(<span class="string">&quot;test.address&quot;</span>, <span class="string">&quot;This is a message&quot;</span>, <span class="number">1000</span>, <span class="keyword">new</span> Handler&lt;AsyncResult&lt;Message&lt;String&gt;&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;Message&lt;String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I received a reply &quot;</span> + message.body);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.err.println(<span class="string">&quot;No reply was received before the 1 second timeout!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当<code>send</code>超时之后，我们可以通过<code>AsyncResult</code>的<code>cause()</code>来获得一个<code>ReplyException</code>异常信息。<code>ReplyException</code>上的<code>failureType()</code>值是<code>ReplyFailure.TIMEOUT</code></p>
<p>你也可以在<code>event bus</code>自身上设置一个超时时间. 如果你在<code>event bus</code>使用带有reply handler的<code>send(...)</code>方法，那这个超时时间就会被使用到。默认的超时时间是<code>-1</code>,这意味着reply handler 永远不会超时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eb.setDefaultReplyTimeout(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">eb.send(<span class="string">&quot;test.address&quot;</span>, <span class="string">&quot;This is a message&quot;</span>, <span class="keyword">new</span> Handler&lt;Message&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I received a reply before the timeout of 5 seconds&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同样，你也可以对reply设置一个超时，然后使用<code>Handler&lt;AsyncResult&lt;Message&gt;&gt;</code>在超时时间内获得reply的reply：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message.replyWithTimeout(<span class="string">&quot;This is a reply&quot;</span>, <span class="number">1000</span>, <span class="keyword">new</span> Handler&lt;AsyncResult&lt;Message&lt;String&gt;&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;Message&lt;String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I received a reply to the reply&quot;</span> + message.body);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;No reply to the reply was received before the 1 second timeout!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Getting-notified-of-reply-failures"><a href="#Getting-notified-of-reply-failures" class="headerlink" title="Getting notified of reply failures"></a>Getting notified of reply failures</h2><p>如果你使用超时和一个<code>result handler</code>去<code>send</code>一个消息，但是没有可用的handler将消息发送出去，那么result handler将会被调用，<code>AsyncResult</code>会是一个失败的状态,同样<code>cause()</code>会返回一个<code>ReplyException</code>. <code>ReplyException</code>实例的<code>failureType()</code>的返回值是<code>ReplyFailure.NO_HANDLERS</code></p>
<p>如果你使用超时和一个<code>result handler</code>去<code>send</code>一个消息，但是接受者通过调用<code>Message.fail(..)</code>回应该消息, <code>result handler</code>会被调用，<code>AsyncResult</code>会是一个失败的状态,同样<code>cause()</code>会返回一个<code>ReplyException</code>. <code>ReplyException</code>实例的<code>failureType()</code>的返回值是<code>ReplyFailure.RECIPIENT_FAILURE</code></p>
<p>For example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">eb.registerHandler(<span class="string">&quot;test.address&quot;</span>, <span class="keyword">new</span> Handler&lt;Message&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        message.fail(<span class="number">123</span>, <span class="string">&quot;Not enough aardvarks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eb.sendWithTimeout(<span class="string">&quot;test.address&quot;</span>, <span class="string">&quot;This is a message&quot;</span>, <span class="number">1000</span>, <span class="keyword">new</span> Handler&lt;AsyncResult&lt;Message&lt;String&gt;&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;Message&lt;String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I received a reply &quot;</span> + message.body);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ReplyException ex = (ReplyException)result.cause();</span><br><span class="line">            System.err.println(<span class="string">&quot;Failure type: &quot;</span> + ex.failureType();</span><br><span class="line">            System.err.println(<span class="string">&quot;Failure code: &quot;</span> + ex.failureCode();</span><br><span class="line">            System.err.println(<span class="string">&quot;Failure message: &quot;</span> + ex.message();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Message-types"><a href="#Message-types" class="headerlink" title="Message types"></a>Message types</h2><p>你发送的消息类型可以是以下几种(包括部分包装类型)</p>
<ul>
<li><code>boolean</code></li>
<li><code>byte[]</code></li>
<li><code>byte</code></li>
<li><code>char</code></li>
<li><code>double</code></li>
<li><code>float</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>short</code></li>
<li><code>java.lang.String</code></li>
<li><code>org.vertx.java.core.json.JsonObject</code></li>
<li><code>org.vertx.java.core.json.JsonArray</code></li>
<li><code>org.vertx.java.core.buffer.Buffer</code></li>
</ul>
<p>如果<code>Vert.x buffers</code> 和 <code>JSON objects and arrays</code>是在相同的JVM里进行传递，那么在传递之前，他们会被copy一份，因此不同的verticle不能访问相同的对象实例，相同的对象实例会引发条件竞争。</p>
<p>Send some numbers:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eb.send(<span class="string">&quot;test.address&quot;</span>, <span class="number">1234</span>);</span><br><span class="line">eb.send(<span class="string">&quot;test.address&quot;</span>, <span class="number">3.14159</span>);</span><br><span class="line">Send a <span class="keyword">boolean</span>:</span><br><span class="line"></span><br><span class="line">eb.send(<span class="string">&quot;test.address&quot;</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>Send a JSON object:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JsonObject obj = <span class="keyword">new</span> JsonObject();</span><br><span class="line">obj.putString(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;wibble&quot;</span>);</span><br><span class="line">eb.send(<span class="string">&quot;test.address&quot;</span>, obj);</span><br></pre></td></tr></table></figure>

<p>Null messages can also be sent:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eb.send(<span class="string">&quot;test.address&quot;</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>使用JSON作为verticle通信协议是一个不错的约定，这是因为JSON可以被所有Vert.x所支持的语言进行编解码</p>
<h2 id="Distributed-event-bus"><a href="#Distributed-event-bus" class="headerlink" title="Distributed event bus"></a>Distributed event bus</h2><p>如果想要在你的特定网络内每一个Vert.x实例都在相同的<code>event bus</code>里，你只需要在命令行里启动Vert.x实例时添加<code>-cluster</code>参数就好了</p>
<p>一旦你成功启动，集群模式下的Vert.x实例就会合并到一起，组成一个分布式的<code>event bus</code></p>
<h1 id="Shared-Data"><a href="#Shared-Data" class="headerlink" title="Shared Data"></a>Shared Data</h1><p>我们可能需要一种安全的方式在不同的verticle间共享数据。 Vert.x允许<code>java.util.concurrent.ConcurrentMap</code>和<code>java.util.Set</code>这俩个数据结构在verticle间共享。</p>
<blockquote>
<p>注意：为了避免可变数据带来的问题，Vert.x只允许简单的不可变类型，例如<code>number, boolean and string or Buffer</code>等数据类型用于做数据共享。当共享一个buffer时， 当我们从共享数据获取<code>Buffer</code>数据时，其实我们只是从共享数据里copy了一个<code>Buffer</code>，因此不同的verticle永远不会访问同一个对象。</p>
</blockquote>
<p>并发数据只能在同一个Vert.x实例中的verticle实例中进行共享。在以后的版本中，Vert.x会允许数据可以在集群中的所有Vert.x实例间进行共享。</p>
<h3 id="Shared-Maps"><a href="#Shared-Maps" class="headerlink" title="Shared Maps"></a>Shared Maps</h3><p>如果想要在不同的verticle中共享一个map。首先我们获得这个map的引用，然后就可以使用<code>java.util.concurrent.ConcurrentMap</code>的共享实例了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;String, Integer&gt; map = vertx.sharedData().getMap(<span class="string">&quot;demo.mymap&quot;</span>);</span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;some-key&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>当然你也可以在其他的verticle中访问它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;String, Integer&gt; map = vertx.sharedData().getMap(<span class="string">&quot;demo.mymap&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// etc</span></span><br></pre></td></tr></table></figure>

<h3 id="Shared-Sets"><a href="#Shared-Sets" class="headerlink" title="Shared Sets"></a>Shared Sets</h3><p>在不同的verticle中使用一个共享的set和使用一个共享的map，方式基本相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = vertx.sharedData().getSet(&quot;demo.myset&quot;);</span><br><span class="line"></span><br><span class="line">set.add(&quot;some-value&quot;);</span><br></pre></td></tr></table></figure>

<p>然后在不同的verticle中使用它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = vertx.sharedData().getSet(&quot;demo.myset&quot;);</span><br><span class="line"></span><br><span class="line">// etc</span><br></pre></td></tr></table></figure>


<h1 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h1><p>在Vert.x中进行数据传播的大多是<code>org.vertx.java.core.buffer.Buffer</code>实例</p>
<p><code>Buffer</code>表示的是一个字节序列(size &gt;= 0), 可以向<code>Buffer</code>写入或者读取数据, 当写入数据时，超过其容量最大值时，会自动拓容。</p>
<h4 id="Creating-Buffers"><a href="#Creating-Buffers" class="headerlink" title="Creating Buffers"></a>Creating Buffers</h4><p>创建一个空<code>Buffer</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = <span class="keyword">new</span> Buffer();</span><br></pre></td></tr></table></figure>

<p>使用<code>String</code>类型创建一个buffer。这个<code>String</code>在<code>Buffer</code>内部以<code>UTF-8</code>进行编码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = <span class="keyword">new</span> Buffer(<span class="string">&quot;some-string&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>指定<code>String</code>编码格式创建一个<code>Buffer</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = <span class="keyword">new</span> Buffer(<span class="string">&quot;some-string&quot;</span>, <span class="string">&quot;UTF-16&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用<code>byte[]</code>创建一个<code>Buffer</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; ... &#125;;</span><br><span class="line"><span class="keyword">new</span> Buffer(bytes);</span><br></pre></td></tr></table></figure>

<p>在创建<code>Buffer</code>实例时，我们也可以指定其大小。当你确定写入buffer的数据大小时，你可以创建一个指定大小的buffer。当buffer创建成功之后，就会分配出指定大小的内存，这种方式比buffer容量不足时，自动拓容要高效的多，但是要慎用，因为它一开始就可能会非常大的内存。</p>
<p>注意，通过指定大小的方式创建出的<code>Buffer</code>实例，给它分配的内存是空的，并不会用0去填充它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = <span class="keyword">new</span> Buffer(<span class="number">100000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Writing-to-a-Buffer"><a href="#Writing-to-a-Buffer" class="headerlink" title="Writing to a Buffer"></a>Writing to a Buffer</h4><p>有俩种方式向一个buffer中写入数据：</p>
<ol>
<li>appending</li>
<li>random access</li>
</ol>
<p>buffer会随着写入的数据的不断增加自动拓容，因此，<code>Buffer</code>实例的写数据操作不可能产生<code>IndexOutOfBoundsException</code>异常</p>
<h5 id="Appending-to-a-Buffer"><a href="#Appending-to-a-Buffer" class="headerlink" title="Appending to a Buffer"></a>Appending to a Buffer</h5><p>想要使用<code>append</code>方式向buffer中写入数据,你只需要调用<code>appendXXX</code>方法. <code>Append</code>方法支持追加<code>buffers, byte[], String and all primitive types</code></p>
<p><code>appendXXX</code>方法会返回<code>Buffer</code>实例自身，所以在也可以直接使用<code>chain</code>模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = <span class="keyword">new</span> Buffer();</span><br><span class="line"></span><br><span class="line">buff.appendInt(<span class="number">123</span>).appendString(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">socket.write(buff);</span><br></pre></td></tr></table></figure>

<h5 id="Random-access-buffer-writes"><a href="#Random-access-buffer-writes" class="headerlink" title="Random access buffer writes"></a>Random access buffer writes</h5><p>你也可以通过<code>setXXX</code>方法在一个指定位置上写入数据。 <code>setXXX</code>方法支持<code>buffers, byte[], String and all primitive types</code>.所有的<code>setXXX</code>方法的第一个参数都是个写入位置的索引值。</p>
<p>无论采用什么写数据的方式,<code>Buffer</code>总会当内存不足时，进行自动拓容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = <span class="keyword">new</span> Buffer();</span><br><span class="line"></span><br><span class="line">buff.setInt(<span class="number">1000</span>, <span class="number">123</span>);</span><br><span class="line">buff.setBytes(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Reading-from-a-Buffer"><a href="#Reading-from-a-Buffer" class="headerlink" title="Reading from a Buffer"></a>Reading from a Buffer</h4><p>我们通过<code>getXXX</code>方法从<code>Buffer</code>里读数据. <code>getXXX</code>方法支持<code>byte[], String and all primitive types</code>. <code>getXXX</code>方法的第一个值是开始读取的位置索引值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Buffer buff = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buff.length(); i += <span class="number">4</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;int value at &quot;</span> + i + <span class="string">&quot; is &quot;</span> + buff.getInt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Other-buffer-methods"><a href="#Other-buffer-methods" class="headerlink" title="Other buffer methods:"></a>Other buffer methods:</h4><ul>
<li>length(). 获得buffer的大小。buffer的length值是buffer的最大索引值 + 1</li>
<li>copy(). 拷贝整个buffer</li>
</ul>
<p>更多方法参考javadoc手册。</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>在javascript中有一等类支持<code>JSON</code>, RUBY中有哈希字面量非常好的支持JSON,但是java并不支持这俩点.</p>
<p>因此,如果你想要在java <code>verticle</code>中使用JSON,我们提供了一些简单的JSON类,这些JSON类可以表示JSON对象或者JSON数组.那些类提供了从一个JSON对象或者数组中set/get JSON支持的所有类型。</p>
<p>JSON对象是<code>org.vertx.java.core.json.JsonObject</code>的实例.JSON数组是<code>org.vertx.java.core.json.JsonArray</code>的实例</p>
<p>下面的例子给出了在java verticle中在从<code>event bus</code>中收发JSON消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EventBus eb = vertx.eventBus();</span><br><span class="line"></span><br><span class="line">JsonObject obj = <span class="keyword">new</span> JsonObject().putString(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;wibble&quot;</span>)</span><br><span class="line">                                 .putNumber(<span class="string">&quot;age&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">eb.send(<span class="string">&quot;some-address&quot;</span>, obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="comment">// And in a handler somewhere:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Message&lt;JsonObject&gt; message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;foo is &quot;</span> + message.body.getString(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;age is &quot;</span> + message.body.getNumber(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还提供了对象和JSON格式之间的转化方法</p>
<p>Please see the JavaDoc for the full Java Json API.</p>
<h1 id="Delayed-and-Periodic-Tasks"><a href="#Delayed-and-Periodic-Tasks" class="headerlink" title="Delayed and Periodic Tasks"></a>Delayed and Periodic Tasks</h1><p>在Vert.x中有一种常用操作就是经过一段时间的延迟后执行某种操作</p>
<p>chap.c在标准verticle中,你不能通过让线程sleep的方式来达到延迟的效果,因为这会阻塞<code>event loop</code>线程</p>
<p>你可以使用Vert.x定时器.定时器可以是one-shot 或者 periodic</p>
<h3 id="One-shot-Timers"><a href="#One-shot-Timers" class="headerlink" title="One-shot Timers"></a>One-shot Timers</h3><p><code>one shot</code>定时器当延迟时间一到就会调用一个<code>event handler</code>.延迟单位是毫秒</p>
<p>你只需要调用<code>setTimer</code>方法,然后向该方法传递需延迟的时间和一个handler.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timerID = vertx.setTimer(<span class="number">1000</span>, <span class="keyword">new</span> Handler&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Long timerID)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;And one second later this is printed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;First this is printed&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>该方法的返回值是一个唯一的定时器ID,我们可以使用该ID取消该定时器</p>
<h3 id="Periodic-Timers"><a href="#Periodic-Timers" class="headerlink" title="Periodic Timers"></a>Periodic Timers</h3><p>你还可以使用<code>setPeriodic</code>方法设置一个阶段定时器.这个定时器每隔一段时间就会执行一次.同样该方法的返回值是一个唯一的定时器ID,我们同样可以使用该ID取消定时器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timerID = vertx.setPeriodic(<span class="number">1000</span>, <span class="keyword">new</span> Handler&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Long timerID)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;And every second this is printed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;First this is printed&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Cancelling-timers"><a href="#Cancelling-timers" class="headerlink" title="Cancelling timers"></a>Cancelling timers</h3><p>我们调用<code>cancelTimer</code>方法可以取消掉<code>periodic timer</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timerID = vertx.setPeriodic(<span class="number">1000</span>, <span class="keyword">new</span> Handler&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Long timerID)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// And immediately cancel it</span></span><br><span class="line"></span><br><span class="line">vertx.cancelTimer(timerID);</span><br></pre></td></tr></table></figure>

<p>或者你可以在event handler里取消它.下面的例子就是在10秒后取消掉了该定时器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timerID = vertx.setPeriodic(<span class="number">1000</span>, <span class="keyword">new</span> Handler&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Long timerID)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;In event handler &quot;</span> + count);</span><br><span class="line">        <span class="keyword">if</span> (++count == <span class="number">10</span>) &#123;</span><br><span class="line">            vertx.cancelTimer(timerID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h1 id="Writing-TCP-Servers-and-Clients"><a href="#Writing-TCP-Servers-and-Clients" class="headerlink" title="Writing TCP Servers and Clients"></a>Writing TCP Servers and Clients</h1><p>通过Vert.x创建TCP的服务器和客户端是非常简单的</p>
<h1 id="Net-Server"><a href="#Net-Server" class="headerlink" title="Net Server"></a>Net Server</h1><h3 id="Creating-a-Net-Server"><a href="#Creating-a-Net-Server" class="headerlink" title="Creating a Net Server"></a>Creating a Net Server</h3><p>我们可以通过<code>vertx</code>实例的<code>createNetServer</code>方法轻松创建一个TCP服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br></pre></td></tr></table></figure>

<h3 id="Start-the-Server-Listening"><a href="#Start-the-Server-Listening" class="headerlink" title="Start the Server Listening"></a>Start the Server Listening</h3><p>接下来我们告诉服务器要监听入站连接的端口号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1234</span>, <span class="string">&quot;myhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>第一个参数是要监听的端口号。如果将要监听的端口号设置为0的话，那服务器会随机出一个可用的端口号。一旦服务器完成监听动作，你可以调用<code>port()</code>方法查看服务器真实监听的端口号。</p>
<p>第二个参数是域名或者IP地址。如果该参数省略不填的话，那么才采取默认值<code>0.0.0.0</code>,这意味着它会监听所有可用的网络接口</p>
<p>实际上的绑定动作是异步的，这意味着，可能你的<code>listen</code>方法已经返回了，但是绑定动作还没有完成。如果你想要开始正式监听时获取一个通知的话，那么你可以在第三个参数上指定一个handler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(<span class="number">1234</span>, <span class="string">&quot;myhost&quot;</span>, <span class="keyword">new</span> AsyncResultHandler&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;NetServer&gt; asyncResult)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Listen succeeded? &quot;</span> + asyncResult.succeeded());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Getting-Notified-of-Incoming-Connections"><a href="#Getting-Notified-of-Incoming-Connections" class="headerlink" title="Getting Notified of Incoming Connections"></a>Getting Notified of Incoming Connections</h3><p>我们需要调用<code>connectHandler</code>来处理到来的网络连接.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(NetSocket sock)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;A client has connected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>connectHandler</code>方法返回值就是服务器自身，因此我们将多个方法调用链式地组合在一起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(NetSocket sock)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;A client has connected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vertx.createNetServer().connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(NetSocket sock)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;A client has connected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Vert.x API大多数都采用这种模式思想</p>
<h3 id="Closing-a-Net-Server"><a href="#Closing-a-Net-Server" class="headerlink" title="Closing a Net Server"></a>Closing a Net Server</h3><p>如果想要结束一个net server，我们只需要调用<code>close</code>方法就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.close();</span><br></pre></td></tr></table></figure>

<p><code>close</code>方法同样是异步的，因此它也有可能close方法已经返回了，但是close操作其实还没完成。当然你如果想要当close完成时获得通知的话，你也可以选择向<code>close</code>方法指定一个handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.close(<span class="keyword">new</span> AsyncResultHandler&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;Void&gt; asyncResult)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Close succeeded? &quot;</span> + asyncResult.succeeded());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果你想要你的net server的生命周期和verticle保持一致，那么你就没必要显式的调用<code>close</code>方法了，当verticle解除部署时，Vert.x container会自动帮你关闭掉服务器</p>
<h3 id="NetServer-Properties"><a href="#NetServer-Properties" class="headerlink" title="NetServer Properties"></a>NetServer Properties</h3><p><code>NetServer</code>有一套属性可以设置，属性可以影响<code>NetServer</code>的行为。首先，这套属性调整的是TCP参数，在大多数情况下，你不需要设置他们。</p>
<ul>
<li><code>setTCPNoDelay(tcpNoDelay)</code> If true then Nagle’s Algorithm is disabled. If false then it is enabled.</li>
<li><code>setSendBufferSize(size)</code> Sets the TCP send buffer size in bytes.</li>
<li><code>setReceiveBufferSize(size)</code> Sets the TCP receive buffer size in bytes.</li>
<li><code>setTCPKeepAlive(keepAlive)</code> if keepAlive is true then TCP keep alive is enabled, if false it is disabled.</li>
<li><code>setReuseAddress(reuse)</code> if reuse is true then addresses in TIME_WAIT state can be reused after they have been closed.</li>
<li><code>setSoLinger(linger)</code></li>
<li><code>setTrafficClass(trafficClass)</code></li>
</ul>
<h3 id="Handling-Data"><a href="#Handling-Data" class="headerlink" title="Handling Data"></a>Handling Data</h3><p>当服务器接受到一个连接，connect handler对象的<code>handler</code>方法会被调用，同时向该方法中传递一个<code>NetSocket</code>对象。<code>NetSocket</code>是一个类Socket接口，该类允许你进行读写数据，甚至还允许你关闭该Socket。</p>
<h4 id="Reading-Data-from-the-Socket"><a href="#Reading-Data-from-the-Socket" class="headerlink" title="Reading Data from the Socket"></a>Reading Data from the Socket</h4><p>如果想要从<code>NetSocket</code>读取数据，你需要在<code>NetSocket</code>上调用<code>dataHandler</code>方法设置一个dataHandler。每当在socket上接受到数据后，dataHandler都会被调用,同时向<code>dataHandler</code>方法传递一个<code>org.vertx.java.core.buffer.Buffer</code>对象。你可以使用下面的例子开启一个服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(NetSocket sock)</span> </span>&#123;</span><br><span class="line">        sock.dataHandler(<span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;I received &quot;</span> + buffer.length() + <span class="string">&quot; bytes of data&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Writing-Data-to-a-Socket"><a href="#Writing-Data-to-a-Socket" class="headerlink" title="Writing Data to a Socket"></a>Writing Data to a Socket</h4><p>如果想要向scoket中写入数据的话，你可以调用<code>write</code>方法，这个方法可以通过下面几种方式进行调用：</p>
<p>With a single buffer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer myBuffer = <span class="keyword">new</span> Buffer(...);</span><br><span class="line">sock.write(myBuffer);</span><br></pre></td></tr></table></figure>

<p>下面我们使用<code>UTF-8</code>编码的字符串，写入到socket中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.write(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>下面我们将指定编码格式化一个字符串，然后写入到socket中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.write(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;UTF-16&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>write</code>方法同样是异步的，当该<code>write</code>方法入栈之后就会立即返回</p>
<p>下面给出了一个TCP 服务器，它将接受到的数据直接返回回去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> NetSocket sock)</span> </span>&#123;</span><br><span class="line">        sock.dataHandler(<span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">                sock.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Socket-Remote-Address"><a href="#Socket-Remote-Address" class="headerlink" title="Socket Remote Address"></a>Socket Remote Address</h3><p>通过<code>remoteAddress()</code>方法你可以获得socket对等端的地址</p>
<h3 id="Socket-Local-Address"><a href="#Socket-Local-Address" class="headerlink" title="Socket Local Address"></a>Socket Local Address</h3><p>通过<code>localAddress()</code>方法你可以获得socket的本地地址</p>
<h3 id="Closing-a-socket"><a href="#Closing-a-socket" class="headerlink" title="Closing a socket"></a>Closing a socket</h3><p><code>close</code>方法会关闭一个socket，它会直接关闭底层的TCP连接</p>
<h3 id="Closed-Handler"><a href="#Closed-Handler" class="headerlink" title="Closed Handler"></a>Closed Handler</h3><p>如果你想当socket关闭时获得通知，你可以设置一个<code>closedHandler</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> NetSocket sock)</span> </span>&#123;</span><br><span class="line">        sock.closedHandler(<span class="keyword">new</span> VoidHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;The socket is now closed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不管是服务器还是客户端，任何一方关闭连接，close handler都会被调用</p>
<h3 id="Exception-handler"><a href="#Exception-handler" class="headerlink" title="Exception handler"></a>Exception handler</h3><p>如果担心通信过程中连接发生异常，你可以设置一个exception handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> NetSocket sock)</span> </span>&#123;</span><br><span class="line">        sock.exceptionHandler(<span class="keyword">new</span> Handler&lt;Throwable&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;Oops, something went wrong&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Event-Bus-Write-Handler"><a href="#Event-Bus-Write-Handler" class="headerlink" title="Event Bus Write Handler"></a>Event Bus Write Handler</h3><p>每一个<code>NetSocket</code>都会自动向<code>event bus</code>上注册一个handler， 当该handler接受到任何buffer之后，它会将buffer写入到<code>NetSocket</code>上。这样一来，由于我们可以通过从不同的verticle里，甚至从不同的Vert.x实例中向向<code>NetSocket</code>注册的<code>event bus</code>地址上写数据，那么我们实现了不单单从传统socket通信的方式向<code>NetSocket</code>写入数据的方式。</p>
<p>我们可以从<code>netSocket</code>上通过<code>writeHandlerID()</code>方法获取注册在<code>event bus</code>上的地址</p>
<p>下面的例子给出了从不同的verticle中向一个<code>NetSocket</code>中写入数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String writeHandlerID = ... <span class="comment">// E.g. retrieve the ID from shared data</span></span><br><span class="line"></span><br><span class="line">vertx.eventBus().send(writeHandlerID, buffer);</span><br></pre></td></tr></table></figure>

<h3 id="Read-and-Write-Streams"><a href="#Read-and-Write-Streams" class="headerlink" title="Read and Write Streams"></a>Read and Write Streams</h3><p>NetSocket also implements org.vertx.java.core.streams.ReadStream and org.vertx.java.core.streams.WriteStream. This allows flow control to occur on the connection and the connection data to be pumped to and from other object such as HTTP requests and responses, WebSockets and asynchronous files.</p>
<p><code>NetSocket</code>实现了<code>org.vertx.java.core.streams.ReadStream</code>和<code>org.vertx.java.core.streams.WriteStream</code>接口。</p>
<h2 id="Scaling-TCP-Servers"><a href="#Scaling-TCP-Servers" class="headerlink" title="Scaling TCP Servers"></a>Scaling TCP Servers</h2><p>每一个verticle实例都是纯单线程的。</p>
<p>如果你在一个verticle上创建了一个TCPserver，而且对该verticle只部署了一个实例，那么在该verticle上所有的handler就总是在同一个event loop上执行。</p>
<p>这意味着，如果你在一个多核心主机上上运行一个服务器，同时你只部署了一个服务器verticle实例，那么你的服务器只会使用该机器的一个核心</p>
<p>为了解决这个情况，你可以在同一个机器上部署多个服务器上module实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx runmod com.mycompany~my-mod~<span class="number">1.0</span> -instances <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>或者部署原生的verticle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vertx run foo.MyApp -instances <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>上面的代码在同一个Vert.x实例上运行了20个module/verticle实例</p>
<p>当你这样部署之后，你会发现，服务器和之前运行的一样，但是，令人惊奇的是，你机器上的所有核心都处于使用状态，而且处理任务的能力也大大增强了</p>
<p>这时，你也许会问自己”等等，你怎么能让多个服务器同时监听相同的IP和端口呢？当你部署运行多个实例的时候不会造成端口冲突吗”</p>
<p>当主机上已经存在一个服务器监听某个<code>host/port</code>的时候，当你再部署一个服务器,监听相同的<code>host/port</code>时，Vert.x并不会新建一个server，再在相同的<code>host/port</code>上进行监听</p>
<blockquote>
<p>Vert.x内部是这样做的，当你尝试部署多个服务器时监听相同的主机和端口时，Vert.x并不会再创建新的服务器对象对相同的主机和端口号进行监听，但是它会在处理网络连接的地方上再注册一个connetc handler(每个)，这么一来就相当于实现了一个处理网络的”集群”</p>
</blockquote>
<p>Vert.x内部只会持有一个服务器，当有连接到来时，Vert.x会根据<code>round-robin</code>算法，在众多的connet handler中选择一个，然后将到来的连接转发到被选择出的那个connet handler上</p>
<p>Consequently Vert.x TCP servers can scale over available cores while each Vert.x verticle instance remains strictly single threaded, and you don’t have to do any special tricks like writing load-balancers in order to scale your server on your multi-core machine.</p>
<p>因此，Vert.x TCP server就可以在非常方便地在可用核心上进行水平拓展，每个verticle实例都被分配到一个单线程上，因此你就不需要自己在多核主机上去实现服务器的负载均衡了。</p>
<h1 id="NetClient"><a href="#NetClient" class="headerlink" title="NetClient"></a>NetClient</h1><p><code>NetClient</code>常常是用来与服务器进行TCP连接</p>
<h3 id="Creating-a-Net-Client"><a href="#Creating-a-Net-Client" class="headerlink" title="Creating a Net Client"></a>Creating a Net Client</h3><p>你只需要通过调用<code>vertx</code>的<code>createNetClient</code>方法就可以创建一个TCP客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetClient client = vertx.createNetClient();</span><br></pre></td></tr></table></figure>

<h3 id="Making-a-Connection"><a href="#Making-a-Connection" class="headerlink" title="Making a Connection"></a>Making a Connection</h3><p>然后调用<code>connect</code>方法就可以连接到服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NetClient client = vertx.createNetClient();</span><br><span class="line"></span><br><span class="line">client.connect(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>, <span class="keyword">new</span> AsyncResultHandler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;NetSocket&gt; asyncResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncResult.succeeded()) &#123;</span><br><span class="line">          log.info(<span class="string">&quot;We have connected! Socket is &quot;</span> + asyncResult.result());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          asyncResult.cause().printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>connetc</code>方法第一个参数是服务器的端口，第二个参数是服务器绑定的域名或者IP地址。第三个参数是一个connect handler，当连接建立成功之后，这个handler就会被调用</p>
<p><code>connect handler</code>泛型参数是<code>AsyncResult&lt;NetSocket&gt;</code>,我们可以从这个对象的<code>result()</code>方法中获取<code>NetSocket</code>对象。你可以像在服务器端那样，在socket上进行读写数据。</p>
<p>当然你也可以像在服务器端那样执行<code>close , set the closed handler, set the exception handler</code>操作</p>
<h3 id="Configuring-Reconnection"><a href="#Configuring-Reconnection" class="headerlink" title="Configuring Reconnection"></a>Configuring Reconnection</h3><p><code>NetClient</code>可以被设置成自动重连或者当它无法连接到服务器/与服务器断开连接后进行断线重连。你可以通过调用<code>setReconnectAttempts</code>和<code>setReconnectInterval</code>方法来实现这样的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NetClient client = vertx.createNetClient();</span><br><span class="line"></span><br><span class="line">client.setReconnectAttempts(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">client.setReconnectInterval(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ReconnectAttempts</code>:该值设定重连服务器的次数。<code>-1</code>表示无限次。默认值是0</li>
<li><code>ReconnectInterval</code>:该值设定重连服务器的间隔。单位是毫秒。默认值是1000</li>
</ul>
<h3 id="NetClient-Properties"><a href="#NetClient-Properties" class="headerlink" title="NetClient Properties"></a>NetClient Properties</h3><p><code>NetClient</code>也有一套TCP Properties，这套属性值的含义和<code>NetServer</code>一样，具体使用参考<code>NetServer</code>就好了。</p>
<h1 id="SSL-Servers"><a href="#SSL-Servers" class="headerlink" title="SSL Servers"></a>SSL Servers</h1><h1 id="SSL-Clients"><a href="#SSL-Clients" class="headerlink" title="SSL Clients"></a>SSL Clients</h1><h1 id="User-Datagram-Protocol-UDP"><a href="#User-Datagram-Protocol-UDP" class="headerlink" title="User Datagram Protocol (UDP)"></a>User Datagram Protocol (UDP)</h1><h1 id="Flow-Control-Streams-and-Pumps"><a href="#Flow-Control-Streams-and-Pumps" class="headerlink" title="Flow Control - Streams and Pumps"></a>Flow Control - Streams and Pumps</h1><p>Vert.x提供了几个对象用于从<code>Buffer</code>中读取和写入数据。</p>
<p>在Vert.x中，调用写入数据的方法会直接返回，但是这个写入操作会在Vert.x内部入列(Vert.x内部有一个写入队列)。</p>
<p>如果你向一个对象中写入数据的速度快于这个对象向底层资源写入数据的速度的话，那么这个写入队列会无限制增长下去，直到最后将全部的可用内存都消耗掉。</p>
<p>为了解决这种问题，Vert.x API中的某些对象提供了<code>flow control</code>功能</p>
<p>我们可以向<code>org.vertx.java.core.streams.ReadStream</code>的实现类写入任何带有<code>flow control</code>功能对象, 我们可以从<code>org.vertx.java.core.streams.WriteStream</code>的实现类中读取出任何带有<code>flow control</code>功能的对象。</p>
<p>下面我们给出一个向<code>ReadStream</code>中读取数据,向<code>WriteStream</code>中写入数据的例子。</p>
<p>A very simple example would be reading from a NetSocket on a server and writing back to the same NetSocket - since NetSocket implements both ReadStream and WriteStream, but you can do this between any ReadStream and any WriteStream, including HTTP requests and response, async files, WebSockets, etc.</p>
<p>一个非常简单的例子是在服务器中从<code>NetSocket</code>中读取数据，然后将数据再写回到相同的<code>NetSocket</code>中,能这样做是因为<code>NetSocket</code>实现了<code>ReadStream</code>和<code>WriteStream</code>接口, 但是你可以在任何实现了<code>ReadStream</code>和<code>WriteStream</code>接口的类之间进行这样的操作,包括<code>HTTP requests and response</code>, <code>async files</code>, <code>WebSockets</code>, 等等.</p>
<p>对于刚才提到的情况，我们可以可以将接受的数据再直接写回到<code>NetSocket</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> NetSocket sock)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sock.dataHandler(<span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Write the data straight back</span></span><br><span class="line">                sock.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在上述的例子中有一个问题：如果从socket中读取数据的速度快于向socket中写入数据的速度，它会慢慢地增长<code>NetSocket</code>中的写入队列，最终会引发内存溢出。例如，如果socket客户端读取数据不是很快，那么慢慢地该连接会阻塞掉。</p>
<p>由于<code>NetSocket</code>实现了<code>WriteStream</code>, 在写入数据之前我们可以检查<code>WriteStream</code>是否已经满了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> NetSocket sock)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sock.dataHandler(<span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!sock.writeQueueFull()) &#123;</span><br><span class="line">                    sock.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的例子中不会引发内存溢出，但是当写入队列写满之后，就会发生丢消息的问题了。我们真的想做的是，当<code>NetSocket</code>的写入队列满了之后，就将<code>NetSocket</code>暂停掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> NetSocket sock)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sock.dataHandler(<span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">                sock.write(buffer);</span><br><span class="line">                <span class="keyword">if</span> (sock.writeQueueFull()) &#123;</span><br><span class="line">                    sock.pause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>貌似我们已经完成了需求，但其实不然。当socket句柄满了之后，<code>NetSocket</code>被暂停了，但是当写入队列缓解之后，我们希望还能唤起暂停的<code>NetSocket</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">final</span> NetSocket sock)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sock.dataHandler(<span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">                sock.write(buffer);</span><br><span class="line">                <span class="keyword">if</span> (sock.writeQueueFull()) &#123;</span><br><span class="line">                    sock.pause();</span><br><span class="line">                    sock.drainHandler(<span class="keyword">new</span> VoidHandler() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            sock.resume();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当写入队列能够接受新的数据时,<code>drainHandler</code>会被调用, 这个操作会让<code>NetSocket</code>重新读取数据。</p>
<p>在我们开发Vert.x应用程序时，这是一种非常普遍的操作，因此我们提供了一个辅助类<code>Pump</code>, 这个类会完成刚才我们写的那一段代码。你可以将<code>Pump</code>看成<code>ReadStream</code>和<code>WriteStream</code>，<code>Pump</code>会自己知道何时重新读写数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NetServer server = vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">server.connectHandler(<span class="keyword">new</span> Handler&lt;NetSocket&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(NetSocket sock)</span> </span>&#123;</span><br><span class="line">        Pump.create(sock, sock).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ReadStream"><a href="#ReadStream" class="headerlink" title="ReadStream"></a>ReadStream</h2><p><code>HttpClientResponse, HttpServerRequest, WebSocket, NetSocket, SockJSSocket and AsyncFile</code>等类都实现了<code>ReadStream</code>接口</p>
<p><code>ReadStream</code>接口定义如下方法：</p>
<ul>
<li><code>dataHandler(handler)</code>: 设置一个从<code>ReadStream</code>读取数据的handler，当有数据到来时，handler会接受到一个<code>buffer</code>对象.</li>
<li><code>pause()</code>: 暂停dataHandler. 调用该方法之后，dataHandler不会再接受新的数据</li>
<li><code>resume()</code>: 激活dataHandler. 如果有数据来临时，dataHandler会被调用.</li>
<li><code>exceptionHandler(handler)</code>: <code>ReadStream</code>中发生异常时，exceptionHandler会被调用.</li>
<li><code>endHandler(handler)</code>: 当流读到结尾时，endHandler会被调用. This might be when EOF is reached if the ReadStream represents a file, or when end of request is reached if it’s an HTTP request, or when the connection is closed if it’s a TCP socket.</li>
</ul>
<h2 id="WriteStream"><a href="#WriteStream" class="headerlink" title="WriteStream"></a>WriteStream</h2><p><code> HttpClientRequest, HttpServerResponse, WebSocket, NetSocket, SockJSSocket and AsyncFile</code>实现了<code>WriteStream</code>接口</p>
<p><code>WriteStream</code>接口定义如下方法：</p>
<ul>
<li><code>write(buffer)</code>: 将<code>Buffer</code>中写入<code>WriteStream</code>.这个方法不会发生阻塞.写入操作在Vert.x内部会向写入队列中入列，写入队列将数据异步地写入底层资源。</li>
<li><code>setWriteQueueMaxSize(size)</code>: set the number of bytes at which the write queue is considered full, and the method * * writeQueueFull() returns true. Note that, even if the write queue is considered full, if write is called the data will still be accepted and queued.</li>
<li><code>writeQueueFull()</code>: 获取write queue是否满了，如果满了，返回true</li>
<li><code>exceptionHandler(handler)</code>: 当<code>WriteStream</code>发生异常时，将会调用这个handler</li>
<li><code>drainHandler(handler)</code>: The handler will be called if the WriteStream is considered no longer full.当<code>WriteStream</code></li>
</ul>
<h2 id="Pump"><a href="#Pump" class="headerlink" title="Pump"></a>Pump</h2><p><code>Pump</code>实例拥有下列方法</p>
<ul>
<li><code>start()</code>: 启动pump.</li>
<li><code>stop()</code>: 停止pump. When the pump starts it is in stopped mode.</li>
<li><code>setWriteQueueMaxSize()</code>: 与<code>WriteStream</code>的<code>setWriteQueueMaxSize</code>意义相同.</li>
<li><code>bytesPumped()</code>: 返回pumped的总的字节数</li>
</ul>
<p><code>Pump</code>可以多次启动和停止</p>
<p>当<code>Pump</code>第一次创建出来后，并不是<code>started</code>状态，你需要调用<code>start()</code>方法来启动它</p>
<h1 id="Writing-HTTP-servers"><a href="#Writing-HTTP-servers" class="headerlink" title="Writing HTTP servers"></a>Writing HTTP servers</h1><p>Vert.x能帮你完成一个全功能的高性能的可扩展的HTTP服务器</p>
<h4 id="Creating-an-HTTP-Server"><a href="#Creating-an-HTTP-Server" class="headerlink" title="Creating an HTTP Server"></a>Creating an HTTP Server</h4><p>调用<code>vertx</code>对象上的<code>createHttpServer</code>就可以创建一个HTTP服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br></pre></td></tr></table></figure>

<h4 id="Start-the-Server-Listening-1"><a href="#Start-the-Server-Listening-1" class="headerlink" title="Start the Server Listening"></a>Start the Server Listening</h4><p>然后我们调用<code>listen</code>绑定土匪用于监听要接收处理的请求的端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="string">&quot;myhost&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>第一个参数是绑定的端口号</li>
<li>第二个参数是主机域名或者IP地址。如果忽略该参数，则服务器会采取默认值<code>0.0.0.0</code>,服务器会在所有可用的网络接口中监听绑定的端口号</li>
</ol>
<p>实际上绑定操作是异步进行的，也就是当<code>listen</code>方法返回之后，并不意味着就绑定成功了。如果你想当绑定真正完成的时候，你可以向<code>listen</code>方法传递一个handler，用以接受绑定成功之后的通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(<span class="number">8080</span>, <span class="string">&quot;myhost&quot;</span>, <span class="keyword">new</span> AsyncResultHandler&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(AsyncResult&lt;HttpServer&gt; asyncResult)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Listen succeeded? &quot;</span> + asyncResult.succeeded());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Getting-Notified-of-Incoming-Requests"><a href="#Getting-Notified-of-Incoming-Requests" class="headerlink" title="Getting Notified of Incoming Requests"></a>Getting Notified of Incoming Requests</h4><p>我们还要设置一个request handler,这个handler是为了当请求到来时，我们能收到通知:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.requestHandler(<span class="keyword">new</span> Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;A request has arrived on the server!&quot;</span>);</span><br><span class="line">        request.response().end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>每当有请求到来时，该handler都会被调用一次，然后向handler方法传递一个<code>org.vertx.java.core.http.HttpServerRequest</code>参数</p>
<p>你可以在verticle中实现一个HTTP 服务器,然后在浏览器里输入<code>http://localhost:8080</code>测试一下</p>
<p>和<code>NetServer</code>一样,<code>requestHandler</code>方法返回的也是它自身,因此我们也可以使用链式调用模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.requestHandler(<span class="keyword">new</span> Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;A request has arrived on the server!&quot;</span>);</span><br><span class="line">        request.response().end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Or:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vertx.createHttpServer().requestHandler(<span class="keyword">new</span> Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerRequest request)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;A request has arrived on the server!&quot;</span>);</span><br><span class="line">        request.response().end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Handling-HTTP-Requests"><a href="#Handling-HTTP-Requests" class="headerlink" title="Handling HTTP Requests"></a>Handling HTTP Requests</h4><p>到目前为止，我们看到了如何创建一个<code>HttpServer</code>以及如何捕获通知,下面让我们看一下如何处理接受到的请求：</p>
<p>当捕获到一个请求时，会将请求封装到一个<code>HttpServerRequest</code>中，接着request handler会被调用。</p>
<p>The handler is called when the headers of the request have been fully read. If the request contains a body, that body may arrive at the server some time after the request handler has been called.</p>
<p>当请求的header被全部读取完之后，该handler就会被调用. 如果请求中包含body，body也许会在request handler被调用之后才达到。</p>
<p><code>HttpServerRequest</code>包含有<code>get the URI, path, request headers and request parameters</code>等功能。我们还可以通过调用该对象的<code>response()</code>方法来获得一个表示服务器向客户端进行回应的对象。</p>
<h5 id="Request-Method"><a href="#Request-Method" class="headerlink" title="Request Method"></a>Request Method</h5><p><code>HttpServerRequest</code>的<code>method()</code>表示的是请求使用的<code>HTTP method</code>(该方法的可能返回值有<code>GET, PUT, POST, DELETE, HEAD, OPTIONS, CONNECT, TRACE, PATCH</code>).</p>
<h5 id="Request-Version"><a href="#Request-Version" class="headerlink" title="Request Version"></a>Request Version</h5><p><code>HttpServerRequest</code>的<code>version()</code>方法返回的当前请求使用的<code>HTTP</code>版本号</p>
<h5 id="Request-URI"><a href="#Request-URI" class="headerlink" title="Request URI"></a>Request URI</h5><p><code>HttpServerRequest</code>的<code>rui()</code>方法返回的完整的<code>URI(Uniform Resource Locator)地址</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a/b/c/page.html?param1=abc&amp;param2=xyz</span><br></pre></td></tr></table></figure>

<p><code>uri()</code>返回将会返回<code>/a/b/c/page.html?param1=abc&amp;param2=xyz</code></p>
<p>请求使用的<code>URI</code>地址可以是绝对的，也可以是相对的，这取决于客户端使用的什么,在大多数情况下使用的都是绝对的</p>
<h5 id="Request-Path"><a href="#Request-Path" class="headerlink" title="Request Path"></a>Request Path</h5><p><code>HttpServerRequest</code>的<code>path()</code>方法返回的是请求路径，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a/b/c/page.html?param1=abc&amp;param2=xyz</span><br></pre></td></tr></table></figure>

<p><code>request.path()</code>将返回<code>/a/b/c/page.html</code></p>
<h5 id="Request-Query"><a href="#Request-Query" class="headerlink" title="Request Query"></a>Request Query</h5><p><code>HttpServerRequest</code>的<code>query()</code>方法返回的是请求查询内容，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a/b/c/page.html?param1=abc&amp;param2=xyz</span><br></pre></td></tr></table></figure>
<p><code>request.query()</code>将返回<code>param1=abc&amp;param2=xyz</code></p>
<h5 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h5><p>我们可以在<code>HttpServerRequest</code>的对象上通过<code>headers()</code>方法获取请求的请求头(<code>org.vertx.java.core.MultiMap</code>对象)。<code>MultiMap</code>允许一个key有多个值(这让人想起的guava)</p>
<p>下面的例子对<code>http://localhost:8080</code>请求输出了请求头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.requestHandler(<span class="keyword">new</span> Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerRequest request)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; header: request.headers().entries()) &#123;</span><br><span class="line">            sb.append(header.getKey()).append(<span class="string">&quot;: &quot;</span>).append(header.getValue()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        request.response().putHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        request.response().end(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Request-params"><a href="#Request-params" class="headerlink" title="Request params"></a>Request params</h5><p>我们通过<code>HttpServerRequest</code>的<code>params()</code>方法获得请求的请求参数,同样请求参数也是用<code>org.vertx.java.core.MultiMap</code>存储.</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/page.html?param1=abc&amp;param2=xyz</span><br></pre></td></tr></table></figure>
<p>Then the params multimap would contain the following entries:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">param1: &#x27;abc&#x27;</span><br><span class="line">param2: &#x27;xyz</span><br></pre></td></tr></table></figure>

<h5 id="Remote-Address"><a href="#Remote-Address" class="headerlink" title="Remote Address"></a>Remote Address</h5><p><code>HttpServerRequest</code>的<code>remoteAddress()</code>返回的是HTTP连接另一端的地址（也就是客户端）</p>
<h5 id="Absolute-URI"><a href="#Absolute-URI" class="headerlink" title="Absolute URI"></a>Absolute URI</h5><p><code>HttpServerRequest</code>的<code>absoluteURI()</code>返回的是请求的相对<code>URI</code>地址</p>
<h5 id="Reading-Data-from-the-Request-Body"><a href="#Reading-Data-from-the-Request-Body" class="headerlink" title="Reading Data from the Request Body"></a>Reading Data from the Request Body</h5><p>有时候我们需要向HTTP body中读取数据。像前面介绍的，当请求头被完整读取出来之后，request handler就会被调用，同时封装一个<code>HttpServerRequest</code>对象传递给该<code>handler</code>，但是该对象并不包含body。这么做是因为，body也许非常大，我们不希望可能因为超过可用内存而引发任何问题。</p>
<p>如果，你想要读取body数据，那么你只需要调用<code>HttpServerRequest</code>的<code>dataHandler</code>方法,通过该方法设置一个data handler，每当接受一次request body块都会调用一次该handler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.requestHandler(<span class="keyword">new</span> Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerRequest request)</span> </span>&#123;</span><br><span class="line">        request.dataHandler(<span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&#x27;I received &#x27;</span> + buffer.length() + <span class="string">&#x27; bytes&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>dataHandler</code>可能不仅仅被调用一次，调用的次数取决于<code>body</code>的大小</p>
<p>这和<code>NetSocket</code>中去读数据非常像</p>
<p><code>HttpServerRequest</code>实现了<code>ReadStream</code>接口,因此你可以将body转接到一个<code>WriteStream</code>中。</p>
<p>在大多数情况下，body并不是非常大而且我们想要一次性就接受到整个body数据，那么你可以像下面这样操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.requestHandler(<span class="keyword">new</span> Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Buffer body = <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        request.dataHandler(<span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">                body.appendBuffer(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        request.endHandler(<span class="keyword">new</span> VoidHandler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">// The entire body has now been received</span></span><br><span class="line">              log.info(<span class="string">&quot;The total body received was &quot;</span> + body.length() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和任何<code>ReadStream</code>的实现类一样,当<code>stream</code>读到尾之后，end handler就会被调用。</p>
<p>如果<code>HTTP</code>请求使用了<code>HTTP chunking</code>,那么每次接收到body里每个HTTP chunk时都会调用一次data handler。</p>
<p>如果想要接收到完整的body数据再解析它的话，这是一种非常通用的用法，因此<code>Vert.x</code>提供了一个<code>bodyHandler</code>方法</p>
<p><code>bodyHandler</code>方法设置的handler，只有当整个body数据接受完之后才会被调用</p>
<p>当body数据非常大的时候，vert.x会将整个body数据换存储在内存里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.requestHandler(<span class="keyword">new</span> Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerRequest request)</span> </span>&#123;</span><br><span class="line">        request.bodyHandler(<span class="keyword">new</span> Handler&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Buffer body)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// The entire body has now been received</span></span><br><span class="line">              log.info(<span class="string">&quot;The total body received was &quot;</span> + body.length() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Handling-Multipart-Form-Uploads"><a href="#Handling-Multipart-Form-Uploads" class="headerlink" title="Handling Multipart Form Uploads"></a>Handling Multipart Form Uploads</h5><p>Vert.x能够理解<code>HTML</code>表单里的文件上传操作. 为了能处理文件上传，你需要在request对象上设置<code>uploadHandler</code>。表单中每上传一个文件，设置的handler都会被调用一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request.expectMultiPart(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">request.uploadHandler(<span class="keyword">new</span> Handler&lt;HttpServerFileUpload&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerFileUpload upload)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>HttpServerFileUpload</code>类实现了<code>ReadStream</code>，因此你可以从该类中读取数据,然后将数据再写入任何实现了<code>WriteStream</code>的对象,例如前文一直提到的<code>Pump</code></p>
<p>你也可以直接使用<code>streamToFileSystem()</code>方法将文件直接输出磁盘上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.expectMultiPart(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">request.uploadHandler(<span class="keyword">new</span> Handler&lt;HttpServerFileUpload&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerFileUpload upload)</span> </span>&#123;</span><br><span class="line">        upload.streamToFileSystem(<span class="string">&quot;uploads/&quot;</span> + upload.filename());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Handling-Multipart-Form-Attributes"><a href="#Handling-Multipart-Form-Attributes" class="headerlink" title="Handling Multipart Form Attributes"></a>Handling Multipart Form Attributes</h5><p>如果客户端发送过来的请求是一个HTML表单请求，那么你可以使用<code>formAttributes</code>读取请求属性列表。我们要确保请求的全部内容(包含header和body)都被读取之后，采取调用<code>formAttributes</code>,这是因为表单属性都存储在了body里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.endHandler(<span class="keyword">new</span> VoidHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The request has been all ready so now we can look at the form attributes</span></span><br><span class="line">        MultiMap attrs = request.formAttributes();</span><br><span class="line">        <span class="comment">// Do something with them</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Setting-Status-Code-and-Message"><a href="#Setting-Status-Code-and-Message" class="headerlink" title="Setting Status Code and Message"></a>Setting Status Code and Message</h4><p>我们使用<code>setStatusCode()</code>可以设置返回给客户端的HTTP状态码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.requestHandler(<span class="keyword">new</span> Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServerRequest request)</span> </span>&#123;</span><br><span class="line">        request.response().setStatusCode(<span class="number">739</span>).setStatusMessage(<span class="string">&quot;Too many gerbils&quot;</span>).end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>你还可以使用<code>setStatusMessage()</code>设置状态消息,如果你不进行手动设置的话，那就会采取默认值</p>
<p>默认的状态码是200</p>
<h4 id="Writing-HTTP-responses"><a href="#Writing-HTTP-responses" class="headerlink" title="Writing HTTP responses"></a>Writing HTTP responses</h4><p>如果你想要向HTTP response写入数据，你直接调用<code>write</code>方法就好了。当response结束之前，你可以多次调用<code>write</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer myBuffer = ...</span><br><span class="line">request.response().write(myBuffer);</span><br></pre></td></tr></table></figure>
<p>向response中写入使用<code>UTF-8</code>编码的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.response().write(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>使用指定的编码对字符串进行编码然后写入到response中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.response().write(&quot;hello&quot;, &quot;UTF-16&quot;);</span><br></pre></td></tr></table></figure>

<p><code>write</code>方法同样是异步的，当write放入到socket的写入队列之后就直接返回(但是此时并不意味着数据就已经写出了)</p>
<p>如果你只想向HTTP response写入一个String或者一个Buffer，那么当你调用完<code>write</code>方法之后，再调用一次<code>end</code>方法就可以了</p>
<p>The first call to write results in the response header being being written to the response.</p>
<p>因此，如果你没使用HTTP chunking，那么当你向response写入数据之前，必须设置<code>Content-Length header</code>。</p>
<h4 id="Ending-HTTP-responses"><a href="#Ending-HTTP-responses" class="headerlink" title="Ending HTTP responses"></a>Ending HTTP responses</h4><p>当你已经向HTTP response写完数据之后，必须手动调用<code>end()</code>方法</p>
<p><code>end</code>方法有如下几种调用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.response().end();</span><br></pre></td></tr></table></figure>

<p>下面这种方式和先调用一个<code>write(String)</code>再调用<code>end()</code>方法是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.response().end(&quot;That&#x27;s all folks&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="Closing-the-underlying-connection"><a href="#Closing-the-underlying-connection" class="headerlink" title="Closing the underlying connection"></a>Closing the underlying connection</h4><p>你可以通过调用<code>close()</code>方法关闭掉当前请求的底层TCP连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.response().close();</span><br></pre></td></tr></table></figure>

<h4 id="Response-headers"><a href="#Response-headers" class="headerlink" title="Response headers"></a>Response headers</h4><p>我们可以通过调用<code>headers()</code>方法获得<code>response header</code>（<code>Multimap</code>），然后通过<code>set</code>方法向其添加<code>response header</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.response().headers().set(&quot;Cheese&quot;, &quot;Stilton&quot;);</span><br><span class="line">request.response().headers().set(&quot;Hat colour&quot;, &quot;Mauve&quot;);</span><br></pre></td></tr></table></figure>

<p>我们还可以通过链式模式调用<code>putHeader</code>方法向HTTP response header添加属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.response().putHeader(&quot;Some-Header&quot;, &quot;elephants&quot;).putHeader(&quot;Pants&quot;, &quot;Absent&quot;);</span><br></pre></td></tr></table></figure>

<p>response header必须在写入body动作之前写入</p>
<h4 id="Chunked-HTTP-Responses-and-Trailers"><a href="#Chunked-HTTP-Responses-and-Trailers" class="headerlink" title="Chunked HTTP Responses and Trailers"></a>Chunked HTTP Responses and Trailers</h4><p>Vert.x支持<code>HTTP Chunked Transfer Encoding</code>, 这种模式会将HTTP response body以chunk的方式写入到socket中，当向clent输出的response body非常大，且其大小未知时，这是非常有用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.response().setChunked(true);</span><br></pre></td></tr></table></figure>

<p>response的默认值是<code>non-chunked</code>,当在chunked模式下，每一次调用<code>response.write(...)</code>都会创建一个新的<code>HTTP chunk</code>写入到socket流中</p>
<p>在chunked模式下，你还可以向response中写入<code>HTTP response trailers</code>,这些数据实际上是被写入到最后一个chunk中。</p>
<p>你可以向下面这样，通过调用<code>trailers()</code>方法向<code>HTTP response trailers</code>中写入数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.response().trailers().add(&quot;Philosophy&quot;, &quot;Solipsism&quot;);</span><br><span class="line">request.response().trailers().add(&quot;Favourite-Shakin-Stevens-Song&quot;, &quot;Behind the Green Door&quot;);</span><br></pre></td></tr></table></figure>
<p>Like headers, individual HTTP response trailers can also be written using the putTrailer() method. This allows a fluent API since calls to putTrailer can be chained:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.response().putTrailer(&quot;Cat-Food&quot;, &quot;Whiskas&quot;).putTrailer(&quot;Eye-Wear&quot;, &quot;Monocle&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="Serving-files-directly-from-disk"><a href="#Serving-files-directly-from-disk" class="headerlink" title="Serving files directly from disk"></a>Serving files directly from disk</h3><p>If you were writing a web server, one way to serve a file from disk would be to open it as an AsyncFile and pump it to the HTTP response. Or you could load it it one go using the file system API and write that to the HTTP response.</p>
<p>Alternatively, Vert.x provides a method which allows you to serve a file from disk to an HTTP response in one operation. Where supported by the underlying operating system this may result in the OS directly transferring bytes from the file to the socket without being copied through userspace at all.</p>
<p>Using sendFile is usually more efficient for large files, but may be slower for small files than using readFile to manually read the file as a buffer and write it directly to the response.</p>
<p>To do this use the sendFile function on the HTTP response. Here’s a simple HTTP web server that serves static files from the local web directory:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.requestHandler(new Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    public void handle(HttpServerRequest req) &#123;</span><br><span class="line">      String file = &quot;&quot;;</span><br><span class="line">      if (req.path().equals(&quot;/&quot;)) &#123;</span><br><span class="line">        file = &quot;index.html&quot;;</span><br><span class="line">      &#125; else if (!req.path().contains(&quot;..&quot;)) &#123;</span><br><span class="line">        file = req.path();</span><br><span class="line">      &#125;</span><br><span class="line">      req.response().sendFile(&quot;web/&quot; + file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(8080, &quot;localhost&quot;);</span><br></pre></td></tr></table></figure>
<p>There’s also a version of sendFile which takes the name of a file to serve if the specified file cannot be found:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.response().sendFile(&quot;web/&quot; + file, &quot;handler_404.html&quot;);</span><br></pre></td></tr></table></figure>
<p>Note: If you use sendFile while using HTTPS it will copy through userspace, since if the kernel is copying data directly from disk to socket it doesn’t give us an opportunity to apply any encryption.</p>
<p>If you’re going to write web servers using Vert.x be careful that users cannot exploit the path to access files outside the directory from which you want to serve them.</p>
<h3 id="Pumping-Responses"><a href="#Pumping-Responses" class="headerlink" title="Pumping Responses"></a>Pumping Responses</h3><p>Since the HTTP Response implements WriteStream you can pump to it from any ReadStream, e.g. an AsyncFile, NetSocket, WebSocket or HttpServerRequest.</p>
<p>Here’s an example which echoes HttpRequest headers and body back in the HttpResponse. It uses a pump for the body, so it will work even if the HTTP request body is much larger than can fit in memory at any one time:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">server.requestHandler(new Handler&lt;HttpServerRequest&gt;() &#123;</span><br><span class="line">    public void handle(final HttpServerRequest req) &#123;</span><br><span class="line">      req.response().headers().set(req.headers());</span><br><span class="line">      Pump.createPump(req, req.response()).start();</span><br><span class="line">      req.endHandler(new VoidHandler() &#123;</span><br><span class="line">        public void handle() &#123;</span><br><span class="line">            req.response().end();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(8080, &quot;localhost&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-Compression"><a href="#HTTP-Compression" class="headerlink" title="HTTP Compression"></a>HTTP Compression</h3><p>Vert.x comes with support for HTTP Compression out of the box. Which means you are able to automatically compress the body of the responses before they are sent back to the Client. If the client does not support HTTP Compression the responses are sent back without compressing the body. This allows to handle Client that support HTTP Compression and those that not support it at the same time.</p>
<p>To enable compression you only need to do:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line">server.setCompressionSupported(true);</span><br></pre></td></tr></table></figure>
<p>The default is false.</p>
<p>When HTTP Compression is enabled the HttpServer will check if the client did include an ‘Accept-Encoding’ header which includes the supported compressions. Common used are deflate and gzip. Both are supported by Vert.x. Once such a header is found the HttpServer will automatically compress the body of the response with one of the supported compressions and send it back to the client.</p>
<p>Be aware that compression may be able to reduce network traffic but is more cpu-intensive.</p>
<h1 id="Writing-HTTP-Clients"><a href="#Writing-HTTP-Clients" class="headerlink" title="Writing HTTP Clients"></a>Writing HTTP Clients</h1><h1 id="Routing-HTTP-requests-with-Pattern-Matching"><a href="#Routing-HTTP-requests-with-Pattern-Matching" class="headerlink" title="Routing HTTP requests with Pattern Matching"></a>Routing HTTP requests with Pattern Matching</h1><h1 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h1><h1 id="SockJS"><a href="#SockJS" class="headerlink" title="SockJS"></a>SockJS</h1><h1 id="SockJS-EventBus-Bridge"><a href="#SockJS-EventBus-Bridge" class="headerlink" title="SockJS - EventBus Bridge"></a>SockJS - EventBus Bridge</h1><h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h1><h1 id="DNS-Client"><a href="#DNS-Client" class="headerlink" title="DNS Client"></a>DNS Client</h1>
      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://wangmingco.github.io/2015/07/08/Java/vertx/vertx2_java_api_manual/" title="Vertx 2 Java Api Manaual" target="_blank" rel="external">https://wangmingco.github.io/2015/07/08/Java/vertx/vertx2_java_api_manual/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/wangmingco" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/wangmingco" target="_blank"><span class="text-dark">向南</span><small class="ml-1x">Coder</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2015/07/13/zookeeper/ZooKeeper%20%E5%8E%9F%E7%90%86/" title="ZooKeeper 原理"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2015/07/02/Java/vertx/vertx2_manual/" title="Vertx 2 Manual"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/wangmingco" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://gitee.com/wangmingco" target="_blank" title="Gitee" data-toggle=tooltip data-placement=top><i class="icon icon-gitee"></i></a></li>
        
        <li><a href="https://weibo.com/wangmingco" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://www.zhihu.com/people/wangmingco" target="_blank" title="Zhihu" data-toggle=tooltip data-placement=top><i class="icon icon-zhihu"></i></a></li>
        
        <li><a href="https://www.douban.com/people/xxxyy/" target="_blank" title="Douban" data-toggle=tooltip data-placement=top><i class="icon icon-douban"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>
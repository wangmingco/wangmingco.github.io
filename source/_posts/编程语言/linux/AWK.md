---
category: 编程语言
tag: awk
date: 2015-10-08
title: AWK
---
# AWK
awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。

语法
```awk
awk [-F  field-separator]  'commands'  input-file(s)
```
* -F: 域分隔符,由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。(我们指定:为分隔符`-F ':'`)
* commands: 'PATTERN{COMMAND}'. PATTERN为模式(正在表达式),COMMAND为要执行的命令.

```awk
awk  -F ':'  'BEGIN {print "start"}  {print $1"} END {print "end"}' ./txt
```
上面的例子是读取`txt`文件,然后使用`:`分割每一行数据,在开始处理的时候输出start，在处理过程中第一列数据，最后输出end。

## 变量

### 内置变量
我们可以在AWK命令中直接使用以下内置变量
```awk
ARGC               命令行参数个数
ARGV               命令行参数排列
ENVIRON            支持队列中系统环境变量的使用
FILENAME           awk浏览的文件名
FNR                浏览文件的记录数
FS                 设置输入域分隔符，等价于命令行 -F选项
NF                 浏览记录的域的个数
NR                 已读的记录数
OFS                输出域分隔符
ORS                输出记录分隔符
RS                 控制记录分隔符
```
例如
```awk
jps -l | awk '{print ARGC}'
```

### 自定义变量
我们通过赋值的方式直接定义一个变量
```awk
jps -l | awk 'BEGIN{size=0;} {size=1+size} {print $1} END{print size}'
```
上面我们定义了一个数值型的size变量.

### 数组

# 运算符
* `= += -= *= /= %= ^= **=`	赋值
* `?:`	C条件表达式
* `||`	逻辑或
* `&&`	逻辑与
* `~ ~!`	匹配正则表达式和不匹配正则表达式
* `< <= > >= != ==`	关系运算符
* `空格`	连接
* `+ -`	加，减
* `* / &`	乘，除与求余
* `+ - !`	一元加，减和逻辑非
* `^ ***`	求幂
* `++ --`	增加或减少，作为前缀或后缀
* `$`	字段引用
* `in`	数组成员


# 流程控制
## 条件语句
下面输出了大于10000的java进程号
```awk
jps -l | awk 'BEGIN{size=0} {if($1>10000) {size++;print $1}} END{print size}'
```

## 循环语句
awk中的循环语句借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。

# 字符串处理
## sub函数
匹配从左侧开始找到的第一个符合规则的字符串，然后使用替换字符串替换这些字符串
```awk
jps -l | awk '{sub(/moon/, "sun")} {print $2}'
```
上面这个例子就使用sun这个字符串替换了$2中的moon字符串。

我们还可以指定在哪列执行查找替换
```awk
jps -l | awk '{sub(/moon/, "sun", $1)} {print $2}'
```
上面的例子中我们只在第一列进行查找替换

## gsub函数
与sub函数不同的是，这个执行的是全局替换
```awk
jps -l | awk '{gsub(/moon/, "sun")} {print $2}'
```

## index函数
返回子字符串第一次被匹配的位置，偏移量从位置1开始
```awk
jps -l | awk '{print$2; $2=index($2, "moon")} {print $2}'
```

## length函数
返回记录的字符数
```awk
jps -l | awk '{print$2; $2=length($2)} {print $2}'
```

## substr函数
返回从位置1开始的子字符串，如果指定长度超过实际长度，就返回整个字符串
```awk
jps -l | awk '{print substr($2, 2, 10)} '
```
上面的例子将$2字符串从第二个字符还是截取，截取10个长度的字符串出来

## toupper和tolower函数
可用于字符串大小间的转换
```awk
awk '{print toupper($2)} '
```

## split函数
可按给定的分隔符把字符串分割为一个数组
```awk
jps -l | awk '{ split($2, array, "/"); print array[3]} '
```
上面的例子我们将$2这一列按照`/`进行分割,然后将分割出的数据存储到array数组里. 注意这里首先不需要转义


# 正则表达式

## \
将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，“n”匹配字符“n”。“\n”匹配换行符。序列“\\”匹配“\”，“\(”匹配“(”。
```awk
awk '/\\/{print $0}' ./txt
```
过滤出带有`\`的行

## ^
匹配输入字符串与最左侧开始的位置的字符串。
```awk
awk '/^\\n/{print $0}' ./txt
```
找到所有以`\n`字符串开始的数据

## $
匹配输入字符串结尾的位置。
```awk
awk '/)。$/{print $0}' ./txt
```
过滤以`)。`结尾的行

## *
零次或多次匹配前面的字符或子表达式。例如，zo* 匹配“z”和“zoo”。* 等效于 {0,}。
```awk
awk '/反向引用*/{print $0}' ./txt
```

## +
一次或多次匹配前面的字符或子表达式。例如，“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}。
```awk
awk '/反向引用+/{print $0}' ./txt
```

## ?
零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。
```awk
awk '/反向引用?/{print $0}' ./txt
```

## {n}
n 是非负整数。正好匹配 n 次。例如，“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。
```awk

```

## {n,}
n 是非负整数。至少匹配 n 次。例如，“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o*”。
```awk

```

## {n,m}
M 和 n 是非负整数，其中 n <= m。匹配至少 n 次，至多 m 次。例如，“o{1,3}”匹配“fooooood”中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。
```awk

```

## .
匹配除“\n”之外的任何单个字符。若要匹配包括“\n”在内的任意字符，请使用诸如“[\s\S]”之类的模式。
```awk

```

## (pattern)
匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果“匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用“\(”或者“\)”。
```awk

```

## (?:pattern)
匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用“or”字符 (|) 组合模式部件的情况很有用。例如，'industr(?:y|ies) 是比 'industry|industries' 更经济的表达式。
```awk

```

## (?=pattern)
执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95|98|NT|2000)' 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
```awk

```

## (?!pattern)
执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95|98|NT|2000)' 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。
```awk

```

## x|y
匹配 x 或 y。
```awk
 awk '/换页符等|十六进制转义码必须正好是两位数长/ {print $0}' ./txt
```

## [xyz]
匹配是否包含xyz中任意一个字符
```awk
awk '/[前面至少有]/ {print $0}' ./txt
```

## [^xyz]
匹配不能包含xyz任意一个字符
```awk
awk '/[^前面至少有]/ {print $0}' ./txt
```

## [a-z]
与`[xyz]`规则相同,只不过这个模式提供了一个范围模式.例如[a-c]实际为匹配[abc]
```awk
awk '/[a-b]/ {print $0}' ./txt
```

## [^a-z]
反向范围字符。匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。
```awk
awk '/[^a-z]/ {print $0}' ./txt
```
需要注意的是'\t'会被匹配出来

## \d
数字字符匹配。等效于 [0-9]。
```awk
awk '/\d/ {print $0}' ./txt
```

## \D
非数字字符匹配。等效于 [^0-9]。
```awk
awk '/\D/ {print $0}' ./txt
```

## \n
换行符匹配。等效于 \x0a 和 \cJ。
```awk
awk '/\n/ {print $0}' ./txt
```

## \r
匹配一个回车符。等效于 \x0d 和 \cM。
```awk
 awk '/\t/ {print $0}' ./txt
```

## \s
匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。
```awk
awk '/\s/ {print $0}' ./txt
```

## \S
匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。
```awk
awk '/\S/ {print $0}' ./txt
```

## \w
匹配任何字类字符，包括下划线。与“[A-Za-z0-9_]”等效。
```awk
awk '/\w/ {print $0}' ./txt
```

## \W
与任何非单词字符匹配。与“[^A-Za-z0-9_]”等效。
```awk
awk '/\W/ {print $0}' ./txt
```
